<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ReplyFlow Dashboard</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&family=Inter:wght@400;500&display=swap"
        rel="stylesheet"
    />
    <style>
        :root {
            /* Use the same palette as the landing page */
            --primary: #0a84ff;
            --secondary: #32d2ff;
            --accent: #ff6b00;
            --bg: #f7fafc;
            --text-dark: #2d3748;
            --text-medium: #4a5568;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            color: var(--text-dark);
            background-color: var(--bg);
            line-height: 1.6;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        header {
            background-color: var(--primary);
            color: white;
            padding: 1rem;
        }

        header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-family: 'Poppins', sans-serif;
        }

        header nav {
            margin-top: 0.5rem;
        }

        header nav a {
            margin-right: 1rem;
            font-weight: 500;
        }

        main {
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        section {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        section h2 {
            margin-top: 0;
            font-family: 'Poppins', sans-serif;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            resize: vertical;
            padding: 0.5rem;
            font-family: inherit;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
        }

        select,
        button {
            padding: 0.5rem 1rem;
            font-family: inherit;
            font-size: 1rem;
            border-radius: 4px;
            border: 1px solid #cbd5e0;
            margin-right: 0.5rem;
        }

        input[type="email"],
        input[type="password"] {
            padding: 0.5rem;
            font-family: inherit;
            font-size: 1rem;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            display: block;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0066cc;
        }

        pre {
            background-color: #f1f5f9;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Spinner overlay to indicate loading state during async operations */
        #spinner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.75);
            z-index: 9999;
        }

        /* The spinning element itself */
        #spinner::after {
            content: '';
            width: 40px;
            height: 40px;
            border: 4px solid var(--primary);
            border-top: 4px solid var(--secondary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Toast notification for success, error and info messages */
        #toast {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 1rem 1.5rem;
            border-radius: 4px;
            background-color: var(--text-dark);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 10000;
            font-size: 0.875rem;
        }

        #toast.success {
            background-color: #38a169; /* green */
        }

        #toast.error {
            background-color: #e53e3e; /* red */
        }

        #toast.info {
            background-color: var(--primary);
        }
    </style>
</head>
<body>
    <header>
        <h1>ReplyFlow Dashboard</h1>
        <nav>
            <a href="index.html">Home</a>
            <a href="dashboard.html">Dashboard</a>
        </nav>
    </header>
    <main>
        <!-- Authentication Section -->
        <section id="auth-section">
            <h2>Account</h2>
            <div id="auth-forms">
                <div style="margin-bottom: 1rem;">
                    <h3>Sign Up</h3>
                    <label for="signupEmail">Email:</label>
                    <input type="email" id="signupEmail" placeholder="you@example.com" />
                    <label for="signupPassword">Password:</label>
                    <input type="password" id="signupPassword" placeholder="Choose a password" />
                    <button id="signupBtn">Sign Up</button>
                </div>
                <div style="margin-bottom: 1rem;">
                    <h3>Login</h3>
                    <label for="loginEmail">Email:</label>
                    <input type="email" id="loginEmail" placeholder="you@example.com" />
                    <label for="loginPassword">Password:</label>
                    <input type="password" id="loginPassword" placeholder="Your password" />
                    <button id="loginBtn">Log In</button>
                </div>
                <p id="authMessage" style="color: var(--accent);"></p>
            </div>
            <div id="user-info" style="display: none;">
                <p><strong>Logged in as:</strong> <span id="userEmail"></span></p>
                <p><strong>Plan:</strong> <span id="userPlan"></span></p>
                <button id="logoutBtn">Log Out</button>
            </div>
        </section>

        <!-- Generate Reply Section -->
        <section id="generate-section">
            <h2>Generate a Reply</h2>
            <label for="commentInput">Enter a social media comment:</label>
            <textarea id="commentInput" placeholder="Type the comment here..."></textarea>
            <button id="generateBtn">Generate Reply</button>
            <pre id="replyResult"></pre>
        </section>

        <!-- Global reply settings section for choosing tone and max tokens -->
        <section id="reply-settings">
            <h2>Reply Settings</h2>
            <p>Select your desired tone and token limit below. These settings apply to all platforms when preparing or posting replies.</p>
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                <label for="toneSelect" style="margin: 0 0.5rem;">Choose a tone:</label>
                <select id="toneSelect">
                    <option value="friendly">Friendly</option>
                    <option value="focused">Focused</option>
                    <option value="enthusiastic">Enthusiastic</option>
                    <option value="professional">Professional</option>
                    <option value="casual">Casual</option>
                    <option value="apologetic">Apologetic</option>
                    <option value="quirky">Quirky</option>
                    <option value="diplomatic">Diplomatic</option>
                </select>
                <label for="maxTokensInput" style="margin: 0 0.5rem;">Max Tokens:</label>
                <input type="number" id="maxTokensInput" min="1" max="120" value="60" style="width: 4rem;" />
            </div>
        </section>

        <!-- Facebook Replies Section -->
        <section id="facebook-section">
            <h2>Facebook Comment Replies</h2>
            <p>
                Use these controls to fetch recent comments on your connected Facebook Pages and
                automatically draft responses. Once you review the drafts, you can post them
                directly back to Facebook.
            </p>
            <!-- Display the currently selected tone and max tokens for clarity -->
            <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                Current tone: <strong id="fbCurrentTone"></strong> | Max tokens: <strong id="fbCurrentTokens"></strong>
            </p>
            <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                <!-- Controls for Facebook integration -->
                <button id="connectFacebookBtn">Connect Facebook</button>
                <!-- Renamed for clarity: Prepare Replies -> Generate Replies -->
                <button id="prepareBtn">Generate Replies</button>
                <button id="postBtn">Post Replies</button>
                <!-- Per‑page limit inputs -->
                <label for="maxPostsInput" style="margin: 0 0.5rem;">Max Posts:</label>
                <input type="number" id="maxPostsInput" min="1" value="10" style="width: 4rem;" />
                <label for="maxCommentsInput" style="margin: 0 0.5rem;">Max Comments:</label>
                <input type="number" id="maxCommentsInput" min="1" value="20" style="width: 4rem;" />
                <!-- Facebook page selector (hidden until multiple pages available) -->
                <label id="fbPageSelectLabel" for="fbPageSelect" style="margin: 0 0.5rem; display: none;">Select Page(s):</label>
                <select id="fbPageSelect" multiple style="display: none; min-width: 8rem;"></select>
            </div>
            <pre id="facebookResult"></pre>
        </section>

        <!-- Instagram Replies Section -->
        <section id="instagram-section">
            <h2>Instagram Comment Replies</h2>
            <p>
                Use these controls to fetch recent comments on your connected Instagram accounts and
                automatically draft responses. This feature is coming soon.
            </p>
            <!-- Display the currently selected tone and max tokens for clarity -->
            <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                Current tone: <strong id="igCurrentTone"></strong> | Max tokens: <strong id="igCurrentTokens"></strong>
            </p>
            <!-- Input controls for max posts and comments -->
            <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                <button id="connectInstagramBtn">Connect Instagram</button>
                <!-- Renamed for clarity: Prepare Replies -> Generate Replies -->
                <button id="prepareInstagramBtn">Generate Replies</button>
                <button id="postInstagramBtn">Post Replies</button>
                <label for="maxPostsInstagramInput" style="margin: 0 0.5rem;">Max Posts:</label>
                <input type="number" id="maxPostsInstagramInput" min="1" value="10" style="width: 4rem;" />
                <label for="maxCommentsInstagramInput" style="margin: 0 0.5rem;">Max Comments:</label>
                <input type="number" id="maxCommentsInstagramInput" min="1" value="20" style="width: 4rem;" />
                <!-- Instagram page selector (hidden by default) -->
                <label id="igPageSelectLabel" for="igPageSelect" style="margin: 0 0.5rem; display: none;">Select IG Page(s):</label>
                <select id="igPageSelect" multiple style="display: none; min-width: 8rem;"></select>
            </div>
            <pre id="instagramResult"></pre>
        </section>

        <!-- X Replies Section -->
        <section id="x-section">
            <h2>X Comment Replies</h2>
            <p>
                Use these controls to fetch recent replies to your posts on X and automatically draft
                responses. This feature is coming soon.
            </p>
            <!-- Display the currently selected tone and max tokens for clarity -->
            <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                Current tone: <strong id="xCurrentTone"></strong> | Max tokens: <strong id="xCurrentTokens"></strong>
            </p>
            <!-- Input controls for max posts and comments -->
            <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                <button id="connectXBtn">Connect X</button>
                <!-- Renamed for clarity: Prepare Replies -> Generate Replies -->
                <button id="prepareXBtn">Generate Replies</button>
                <button id="postXBtn">Post Replies</button>
                <label for="maxPostsXInput" style="margin: 0 0.5rem;">Max Posts:</label>
                <input type="number" id="maxPostsXInput" min="1" value="10" style="width: 4rem;" />
                <label for="maxCommentsXInput" style="margin: 0 0.5rem;">Max Comments:</label>
                <input type="number" id="maxCommentsXInput" min="1" value="20" style="width: 4rem;" />
            </div>
            <pre id="xResult"></pre>
        </section>

        <!-- Reddit Replies Section -->
        <section id="reddit-section">
            <h2>Reddit Comment Replies</h2>
            <p>
                Use these controls to fetch recent comments from your Reddit posts and automatically
                draft responses. This feature is coming soon.
            </p>
            <!-- Display the currently selected tone and max tokens for clarity -->
            <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                Current tone: <strong id="redditCurrentTone"></strong> | Max tokens: <strong id="redditCurrentTokens"></strong>
            </p>
            <!-- Input controls for max posts and comments -->
            <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                <button id="connectRedditBtn">Connect Reddit</button>
                <!-- Renamed for clarity: Prepare Replies -> Generate Replies -->
                <button id="prepareRedditBtn">Generate Replies</button>
                <button id="postRedditBtn">Post Replies</button>
                <label for="maxPostsRedditInput" style="margin: 0 0.5rem;">Max Posts:</label>
                <input type="number" id="maxPostsRedditInput" min="1" value="10" style="width: 4rem;" />
                <label for="maxCommentsRedditInput" style="margin: 0 0.5rem;">Max Comments:</label>
                <input type="number" id="maxCommentsRedditInput" min="1" value="20" style="width: 4rem;" />
            </div>
            <pre id="redditResult"></pre>
        </section>

        <!-- Failed Replies Log Section -->
        <section id="log-section">
            <h2>Failed Replies Log</h2>
            <p>
                View errors encountered while posting replies to social platforms. Use this
                tool to debug why certain replies couldn't be posted. You can also
                clear the log after reviewing it. Logs are stored only in memory and
                are not persisted across server restarts.
            </p>
            <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                <button id="viewLogsBtn">View Logs</button>
                <button id="clearLogsBtn">Clear Logs</button>
            </div>
            <pre id="logResult"></pre>
        </section>
    </main>
    <!-- Global spinner overlay and toast notification elements -->
    <div id="spinner"></div>
    <div id="toast" class="toast"></div>
    <script>
        // Base URL for the API. If your backend runs on another host or port, change this.
        // Set your backend API base URL. For local development, use http://127.0.0.1:8000
        // If your backend is hosted on a different domain, update this value accordingly.
        // Base URL for the backend API. Updated to point to the deployed Render service.
        const API_BASE_URL = 'https://replyflow-mvp-backend.onrender.com';

        const commentInput = document.getElementById('commentInput');
        const toneSelect = document.getElementById('toneSelect');
        const generateBtn = document.getElementById('generateBtn');
        const replyResult = document.getElementById('replyResult');

        // Update tone display when the tone or max tokens change
        if (toneSelect) {
            toneSelect.addEventListener('change', updateToneDisplays);
        }
        if (maxTokensInput) {
            maxTokensInput.addEventListener('change', updateToneDisplays);
        }

        const prepareBtn = document.getElementById('prepareBtn');
        const postBtn = document.getElementById('postBtn');
        const facebookResult = document.getElementById('facebookResult');
        const connectFacebookBtn = document.getElementById('connectFacebookBtn');

        // Per‑page limit inputs for Facebook
        const maxPostsInput = document.getElementById('maxPostsInput');
        const maxCommentsInput = document.getElementById('maxCommentsInput');

        // Global input for limiting the number of tokens per reply
        const maxTokensInput = document.getElementById('maxTokensInput');

        /**
         * Load saved max_tokens value from localStorage and apply it to the
         * maxTokensInput. If a saved value exists within the 1–120 range, it
         * will be set on the input. Otherwise the default value remains.
         */
        function loadMaxTokens() {
            try {
                const saved = localStorage.getItem('reply_max_tokens');
                const val = parseInt(saved);
                if (!isNaN(val) && val >= 1 && val <= 120) {
                    maxTokensInput.value = val;
                }
            } catch (e) {
                // ignore any errors
            }
        }

        /**
         * Persist the current value of maxTokensInput to localStorage. Only
         * values within the valid range (1–120) are stored.
         */
        function saveMaxTokens() {
            const val = parseInt(maxTokensInput.value);
            if (!isNaN(val) && val >= 1 && val <= 120) {
                try {
                    localStorage.setItem('reply_max_tokens', val.toString());
                } catch (e) {
                    // ignore storage errors
                }
            }
        }

        // Facebook page selector elements (multi-select) and label
        const fbPageSelect = document.getElementById('fbPageSelect');
        const fbPageSelectLabel = document.getElementById('fbPageSelectLabel');

        /**
         * Load the list of connected Facebook pages and populate the multi-select.
         * This function calls the /admin/facebook_pages endpoint to retrieve
         * page IDs and names. It then shows the selector only if more than
         * one page is available. Previously selected pages (stored in
         * localStorage under 'fb_selected_pages') are automatically
         * pre‑selected.
         */
        async function loadFacebookPages() {
            const token = getToken();
            // If no token or no fetch API, hide the selector and return
            if (!token) {
                fbPageSelect.style.display = 'none';
                fbPageSelectLabel.style.display = 'none';
                return;
            }
            try {
                const res = await fetch(`${API_BASE_URL}/admin/facebook_pages`, {
                    headers: { 'Authorization': `Bearer ${token}` },
                });
                if (!res.ok) {
                    fbPageSelect.style.display = 'none';
                    fbPageSelectLabel.style.display = 'none';
                    return;
                }
                const pages = await res.json();
                if (!Array.isArray(pages) || pages.length === 0) {
                    fbPageSelect.style.display = 'none';
                    fbPageSelectLabel.style.display = 'none';
                    return;
                }
                // Clear any existing options
                fbPageSelect.innerHTML = '';
                // Retrieve previously selected pages from localStorage
                let savedIds = [];
                try {
                    const saved = localStorage.getItem('fb_selected_pages');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed)) {
                            savedIds = parsed;
                        }
                    }
                } catch (e) {
                    savedIds = [];
                }
                // Populate options and pre-select saved ones
                pages.forEach((page) => {
                    const opt = document.createElement('option');
                    opt.value = page.id;
                    opt.textContent = page.name;
                    if (savedIds.includes(page.id)) {
                        opt.selected = true;
                    }
                    fbPageSelect.appendChild(opt);
                });
                // Show or hide the selector based on number of pages
                if (pages.length > 1) {
                    fbPageSelect.style.display = '';
                    fbPageSelectLabel.style.display = '';
                } else {
                    fbPageSelect.style.display = 'none';
                    fbPageSelectLabel.style.display = 'none';
                }
            } catch (e) {
                fbPageSelect.style.display = 'none';
                fbPageSelectLabel.style.display = 'none';
            }
        }

        /**
         * Retrieve currently selected Facebook page IDs from the multi-select.
         * The selected IDs are stored in localStorage (fb_selected_pages) so
         * they can be restored on future visits. Returns an array of
         * selected IDs. If no selector exists or no options are selected,
         * returns an empty array.
         */
        function getSelectedPageIds() {
            const select = fbPageSelect;
            if (!select || select.style.display === 'none') {
                return [];
            }
            const selected = Array.from(select.options)
                .filter((opt) => opt.selected)
                .map((opt) => opt.value);
            try {
                localStorage.setItem('fb_selected_pages', JSON.stringify(selected));
            } catch (e) {
                // Ignore storage errors (e.g., quota exceeded)
            }
            return selected;
        }

        /**
         * Load Instagram pages/accounts and populate the IG page selector.
         * This mirrors loadFacebookPages but stores selections under
         * 'ig_selected_pages' in localStorage. It fetches the same list
         * of connected Facebook pages because Instagram accounts are
         * associated with the Facebook Page tokens. If more than one
         * page/account exists, the selector is shown; otherwise it remains
         * hidden.
         */
        async function loadInstagramPages() {
            const token = getToken();
            if (!token) {
                igPageSelect.style.display = 'none';
                igPageSelectLabel.style.display = 'none';
                return;
            }
            try {
                const res = await fetch(`${API_BASE_URL}/admin/facebook_pages`, {
                    headers: { 'Authorization': `Bearer ${token}` },
                });
                if (!res.ok) {
                    igPageSelect.style.display = 'none';
                    igPageSelectLabel.style.display = 'none';
                    return;
                }
                const pages = await res.json();
                if (!Array.isArray(pages) || pages.length === 0) {
                    igPageSelect.style.display = 'none';
                    igPageSelectLabel.style.display = 'none';
                    return;
                }
                igPageSelect.innerHTML = '';
                let savedIds = [];
                try {
                    const saved = localStorage.getItem('ig_selected_pages');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed)) {
                            savedIds = parsed;
                        }
                    }
                } catch (e) {
                    savedIds = [];
                }
                pages.forEach((page) => {
                    const opt = document.createElement('option');
                    opt.value = page.id;
                    opt.textContent = page.name;
                    if (savedIds.includes(page.id)) {
                        opt.selected = true;
                    }
                    igPageSelect.appendChild(opt);
                });
                if (pages.length > 1) {
                    igPageSelect.style.display = '';
                    igPageSelectLabel.style.display = '';
                } else {
                    igPageSelect.style.display = 'none';
                    igPageSelectLabel.style.display = 'none';
                }
            } catch (e) {
                igPageSelect.style.display = 'none';
                igPageSelectLabel.style.display = 'none';
            }
        }

        /**
         * Retrieve selected Instagram page IDs and persist them to localStorage.
         * Returns an array of selected page IDs. If the selector is hidden or
         * undefined, returns an empty array.
         */
        function getSelectedInstagramPageIds() {
            const select = igPageSelect;
            if (!select || select.style.display === 'none') {
                return [];
            }
            const selected = Array.from(select.options)
                .filter((opt) => opt.selected)
                .map((opt) => opt.value);
            try {
                localStorage.setItem('ig_selected_pages', JSON.stringify(selected));
            } catch (e) {}
            return selected;
        }

        // Instagram elements
        const connectInstagramBtn = document.getElementById('connectInstagramBtn');
        const prepareInstagramBtn = document.getElementById('prepareInstagramBtn');
        const postInstagramBtn = document.getElementById('postInstagramBtn');
        const instagramResult = document.getElementById('instagramResult');

        // Instagram per‑page limit inputs
        const maxPostsInstagramInput = document.getElementById('maxPostsInstagramInput');
        const maxCommentsInstagramInput = document.getElementById('maxCommentsInstagramInput');

        // Instagram page selector elements and label (for multi-account/page support)
        const igPageSelect = document.getElementById('igPageSelect');
        const igPageSelectLabel = document.getElementById('igPageSelectLabel');

        // X (Twitter) elements
        const connectXBtn = document.getElementById('connectXBtn');
        const prepareXBtn = document.getElementById('prepareXBtn');
        const postXBtn = document.getElementById('postXBtn');
        const xResult = document.getElementById('xResult');

        // X per‑page limit inputs
        const maxPostsXInput = document.getElementById('maxPostsXInput');
        const maxCommentsXInput = document.getElementById('maxCommentsXInput');

        // Reddit elements
        const connectRedditBtn = document.getElementById('connectRedditBtn');
        const prepareRedditBtn = document.getElementById('prepareRedditBtn');
        const postRedditBtn = document.getElementById('postRedditBtn');
        const redditResult = document.getElementById('redditResult');

        // Reddit per‑page limit inputs
        const maxPostsRedditInput = document.getElementById('maxPostsRedditInput');
        const maxCommentsRedditInput = document.getElementById('maxCommentsRedditInput');

        // Failed replies log elements
        const viewLogsBtn = document.getElementById('viewLogsBtn');
        const clearLogsBtn = document.getElementById('clearLogsBtn');
        const logResult = document.getElementById('logResult');

        // Spinner and toast elements. The spinner shows a loading overlay during async actions.
        // The toast displays brief notifications (success, error, info) to the user.
        const spinner = document.getElementById('spinner');
        const toastEl = document.getElementById('toast');

        /**
         * Show the spinner overlay. Call this before starting an async operation.
         */
        function showSpinner() {
            if (spinner) {
                spinner.style.display = 'flex';
            }
        }

        /**
         * Hide the spinner overlay. Call this after an async operation completes.
         */
        function hideSpinner() {
            if (spinner) {
                spinner.style.display = 'none';
            }
        }

        /**
         * Display a toast notification with a message and optional type.
         * Type can be 'success', 'error' or 'info' which affects the color.
         * The toast automatically hides after 3 seconds.
         * @param {string} message The message to display
         * @param {string} [type='info'] The type of toast (success, error, info)
         */
        function showToast(message, type = 'info') {
            if (!toastEl) return;
            // Reset existing classes
            toastEl.className = 'toast';
            if (type === 'success' || type === 'error' || type === 'info') {
                toastEl.classList.add(type);
            }
            toastEl.textContent = message;
            toastEl.style.display = 'block';
            // Hide after 3 seconds
            setTimeout(() => {
                toastEl.style.display = 'none';
                toastEl.className = 'toast';
            }, 3000);
        }

        /**
         * Update the displayed current tone and token limit in each platform section. This
         * helps users understand which tone and max token values will be used when
         * generating and posting replies. The displays are defined in each platform
         * section (fbCurrentTone, fbCurrentTokens, igCurrentTone, igCurrentTokens, etc.).
         */
        function updateToneDisplays() {
            const tone = toneSelect?.value || '';
            const tokens = maxTokensInput?.value || '';
            // Update Facebook display
            const fbToneEl = document.getElementById('fbCurrentTone');
            const fbTokensEl = document.getElementById('fbCurrentTokens');
            if (fbToneEl) fbToneEl.textContent = tone;
            if (fbTokensEl) fbTokensEl.textContent = tokens;
            // Update Instagram display
            const igToneEl = document.getElementById('igCurrentTone');
            const igTokensEl = document.getElementById('igCurrentTokens');
            if (igToneEl) igToneEl.textContent = tone;
            if (igTokensEl) igTokensEl.textContent = tokens;
            // Update X (Twitter) display
            const xToneEl = document.getElementById('xCurrentTone');
            const xTokensEl = document.getElementById('xCurrentTokens');
            if (xToneEl) xToneEl.textContent = tone;
            if (xTokensEl) xTokensEl.textContent = tokens;
            // Update Reddit display
            const redditToneEl = document.getElementById('redditCurrentTone');
            const redditTokensEl = document.getElementById('redditCurrentTokens');
            if (redditToneEl) redditToneEl.textContent = tone;
            if (redditTokensEl) redditTokensEl.textContent = tokens;
        }

        /**
         * Persist the current X (Twitter) limits (max posts/comments) to localStorage.
         * These values are used to restore the user's last selection on reload.
         */
        function saveXLimits() {
            try {
                localStorage.setItem('x_max_posts', maxPostsXInput.value);
                localStorage.setItem('x_max_comments', maxCommentsXInput.value);
            } catch (e) {
                // Ignore storage errors
            }
        }

        /**
         * Load saved X (Twitter) limits from localStorage and apply them to the inputs.
         */
        function loadXLimits() {
            try {
                const mp = localStorage.getItem('x_max_posts');
                const mc = localStorage.getItem('x_max_comments');
                if (mp !== null) {
                    maxPostsXInput.value = mp;
                }
                if (mc !== null) {
                    maxCommentsXInput.value = mc;
                }
            } catch (e) {
                // Ignore errors
            }
        }

        /**
         * Persist the current Reddit limits (max posts/comments) to localStorage.
         */
        function saveRedditLimits() {
            try {
                localStorage.setItem('reddit_max_posts', maxPostsRedditInput.value);
                localStorage.setItem('reddit_max_comments', maxCommentsRedditInput.value);
            } catch (e) {}
        }

        /**
         * Load saved Reddit limits from localStorage and apply them to the inputs.
         */
        function loadRedditLimits() {
            try {
                const mp = localStorage.getItem('reddit_max_posts');
                const mc = localStorage.getItem('reddit_max_comments');
                if (mp !== null) {
                    maxPostsRedditInput.value = mp;
                }
                if (mc !== null) {
                    maxCommentsRedditInput.value = mc;
                }
            } catch (e) {}
        }

        // Auth elements
        const signupEmail = document.getElementById('signupEmail');
        const signupPassword = document.getElementById('signupPassword');
        const signupBtn = document.getElementById('signupBtn');
        const loginEmail = document.getElementById('loginEmail');
        const loginPassword = document.getElementById('loginPassword');
        const loginBtn = document.getElementById('loginBtn');
        const authMessage = document.getElementById('authMessage');
        const userInfo = document.getElementById('user-info');
        const userEmail = document.getElementById('userEmail');
        const userPlan = document.getElementById('userPlan');
        const logoutBtn = document.getElementById('logoutBtn');

        // Helper to get auth token from localStorage
        function getToken() {
            return localStorage.getItem('replyflow_token');
        }

        // Save token to localStorage
        function setToken(token) {
            localStorage.setItem('replyflow_token', token);
        }

        // Remove token
        function clearToken() {
            localStorage.removeItem('replyflow_token');
        }

        // Update UI based on authentication state
        async function updateAuthUI() {
            const token = getToken();
            // Always restore saved limits for X and Reddit regardless of auth state. This
            // ensures the inputs show the user's last selected values even when
            // they are not logged in.
            loadXLimits();
            loadRedditLimits();
            if (!token) {
                // Show auth forms, hide user info and disable Facebook actions
                document.getElementById('auth-forms').style.display = '';
                userInfo.style.display = 'none';
                prepareBtn.disabled = true;
                postBtn.disabled = true;
                prepareInstagramBtn.disabled = true;
                postInstagramBtn.disabled = true;
                prepareXBtn.disabled = true;
                postXBtn.disabled = true;
                prepareRedditBtn.disabled = true;
                postRedditBtn.disabled = true;
                // Disable log buttons when not logged in
                if (viewLogsBtn) viewLogsBtn.disabled = true;
                if (clearLogsBtn) clearLogsBtn.disabled = true;
            } else {
                // Hide forms, show user info, enable all platform actions
                document.getElementById('auth-forms').style.display = 'none';
                prepareBtn.disabled = false;
                postBtn.disabled = false;
                prepareInstagramBtn.disabled = false;
                postInstagramBtn.disabled = false;
                prepareXBtn.disabled = false;
                postXBtn.disabled = false;
                prepareRedditBtn.disabled = false;
                postRedditBtn.disabled = false;
                // Enable log buttons when logged in
                if (viewLogsBtn) viewLogsBtn.disabled = false;
                if (clearLogsBtn) clearLogsBtn.disabled = false;
                try {
                    const res = await fetch(`${API_BASE_URL}/me`, {
                        headers: { 'Authorization': `Bearer ${token}` },
                    });
                    if (res.ok) {
                        const data = await res.json();
                        userEmail.textContent = data.email;
                        userPlan.textContent = data.plan || 'None';
                    }
                } catch (e) {
                    // ignore errors
                }
                userInfo.style.display = '';
                // After showing user info, check whether Facebook is already connected
                await checkFacebookConnection();
                // Load Facebook pages to populate the page selector. This will
                // show or hide the selector depending on the number of pages.
                await loadFacebookPages();
                // Load Instagram pages/accounts to populate the IG selector. This
                // mirrors the Facebook page loader but uses its own storage key.
                await loadInstagramPages();
            }
        }

        // Sign up handler
        signupBtn.addEventListener('click', async () => {
            const email = signupEmail.value.trim();
            const password = signupPassword.value;
            if (!email || !password) {
                authMessage.textContent = 'Please enter a valid email and password.';
                return;
            }
            // Use spinner and toast for visual feedback
            authMessage.textContent = '';
            showSpinner();
            try {
                const response = await fetch(`${API_BASE_URL}/signup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password }),
                });
                if (!response.ok) {
                    const err = await response.json().catch(() => null);
                    throw new Error(err?.detail || 'Sign up failed');
                }
                hideSpinner();
                // Show a toast indicating success
                showToast('Sign up successful. Please log in.', 'success');
                signupEmail.value = '';
                signupPassword.value = '';
            } catch (error) {
                hideSpinner();
                // Show error toast and update the auth message
                showToast(`Error: ${error.message}`, 'error');
                authMessage.textContent = `Error: ${error.message}`;
            }
        });

        // Login handler
        loginBtn.addEventListener('click', async () => {
            const email = loginEmail.value.trim();
            const password = loginPassword.value;
            if (!email || !password) {
                authMessage.textContent = 'Please enter your email and password.';
                return;
            }
            // Reset message and show spinner
            authMessage.textContent = '';
            showSpinner();
            try {
                const response = await fetch(`${API_BASE_URL}/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password }),
                });
                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.detail || 'Login failed');
                }
                setToken(data.access_token);
                hideSpinner();
                // Show success toast and update UI
                showToast('Logged in successfully.', 'success');
                loginEmail.value = '';
                loginPassword.value = '';
                await updateAuthUI();
            } catch (error) {
                hideSpinner();
                showToast(`Error: ${error.message}`, 'error');
                authMessage.textContent = `Error: ${error.message}`;
            }
        });

        // Logout handler
        logoutBtn.addEventListener('click', () => {
            clearToken();
            userEmail.textContent = '';
            userPlan.textContent = '';
            updateAuthUI();
        });

        // Initialize UI on load
        // Load previously saved max_tokens value and update tone displays
        loadMaxTokens();
        updateToneDisplays();
        updateAuthUI();

        generateBtn.addEventListener('click', async () => {
            const comment = commentInput.value.trim();
            const tone = toneSelect.value;
            if (!comment) {
                replyResult.textContent = 'Please enter a comment to generate a reply.';
                return;
            }
            replyResult.textContent = '';
            // Show spinner while generating
            showSpinner();
            try {
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                // Persist the current max_tokens to localStorage
                saveMaxTokens();
                // Build request payload including optional max_tokens
                const payload = { comment, tone };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) {
                    payload.max_tokens = mtVal;
                }
                const response = await fetch(`${API_BASE_URL}/generate_reply`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload),
                });
                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(err || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                replyResult.textContent = data.reply || JSON.stringify(data, null, 2);
                showToast('Reply generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                replyResult.textContent = `Error: ${error.message}`;
                showToast(`Error: ${error.message}`, 'error');
            }
        });

        prepareBtn.addEventListener('click', async () => {
            // Clear previous result and show spinner
            facebookResult.textContent = '';
            showSpinner();
            try {
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                // Build request body including tone and per‑page limits if provided
                // Persist the current max_tokens to localStorage
                saveMaxTokens();
                const bodyData = { tone: toneSelect.value };
                // Include max_tokens if specified
                const mt = parseInt(maxTokensInput.value);
                if (!isNaN(mt) && mt > 0) {
                    bodyData.max_tokens = mt;
                }
                const maxPostsVal = parseInt(maxPostsInput.value);
                const maxCommentsVal = parseInt(maxCommentsInput.value);
                if (!isNaN(maxPostsVal) && maxPostsVal > 0) {
                    bodyData.max_posts = maxPostsVal;
                }
                if (!isNaN(maxCommentsVal) && maxCommentsVal > 0) {
                    bodyData.max_comments = maxCommentsVal;
                }
                // Include selected page IDs from the multi-select if any
                const selectedIds = getSelectedPageIds();
                if (Array.isArray(selectedIds) && selectedIds.length > 0) {
                    bodyData.page_ids = selectedIds;
                }
                const response = await fetch(`${API_BASE_URL}/facebook/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(err || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                facebookResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies prepared successfully.', 'success');
            } catch (error) {
                hideSpinner();
                facebookResult.textContent = `Error: ${error.message}`;
                showToast(`Error: ${error.message}`, 'error');
            }
        });

        postBtn.addEventListener('click', async () => {
            // Confirm with the user before posting actual replies.
            const proceed = confirm(
                'This will post replies to Facebook. Are you sure you want to proceed?'
            );
            if (!proceed) {
                return;
            }
            facebookResult.textContent = '';
            showSpinner();
            try {
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                // Build request body including tone and per‑page limits if provided
                // Persist the current max_tokens to localStorage
                saveMaxTokens();
                const bodyDataPost = { tone: toneSelect.value };
                // Include max_tokens if specified
                const mt2 = parseInt(maxTokensInput.value);
                if (!isNaN(mt2) && mt2 > 0) {
                    bodyDataPost.max_tokens = mt2;
                }
                const maxPostsVal2 = parseInt(maxPostsInput.value);
                const maxCommentsVal2 = parseInt(maxCommentsInput.value);
                if (!isNaN(maxPostsVal2) && maxPostsVal2 > 0) {
                    bodyDataPost.max_posts = maxPostsVal2;
                }
                if (!isNaN(maxCommentsVal2) && maxCommentsVal2 > 0) {
                    bodyDataPost.max_comments = maxCommentsVal2;
                }
                // Include selected page IDs from the multi-select if any
                const selectedIdsPost = getSelectedPageIds();
                if (Array.isArray(selectedIdsPost) && selectedIdsPost.length > 0) {
                    bodyDataPost.page_ids = selectedIdsPost;
                }
                const response = await fetch(`${API_BASE_URL}/facebook/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyDataPost),
                });
                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(err || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                facebookResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                facebookResult.textContent = `Error: ${error.message}`;
                showToast(`Error: ${error.message}`, 'error');
            }
        });

        // Connect Facebook handler. Redirects the user to the backend Facebook login route to start the OAuth flow.
        connectFacebookBtn.addEventListener('click', () => {
            // Retrieve the current auth token from localStorage. The backend requires a session token
            // to associate the OAuth flow with the logged‑in user. If no token is found, the
            // backend will redirect to the login page.
            const token = getToken();
            // Build the Facebook OAuth initiation URL, including the token if present.
            let url = `${API_BASE_URL}/facebook/login`;
            if (token) {
                url += `?token=${encodeURIComponent(token)}`;
            }
            // Open the OAuth flow in a new popup window so the dashboard remains visible.
            // This prevents the current page from navigating away to another domain and losing UI state.
            window.open(url, 'facebook_oauth', 'width=600,height=700');
            // Inform the user that a popup has opened
            showToast('A popup window has opened. Please complete the Facebook login.', 'info');
        });

        // Instagram integration handlers
        // For now the Instagram feature is not yet available. Inform the user and
        // avoid initiating any API calls. This preserves UI state while
        // communicating that the integration is under development.
        connectInstagramBtn.addEventListener('click', () => {
            // Show spinner briefly to give feedback even though no real action occurs yet
            // Persist current max_tokens for consistency across sessions
            saveMaxTokens();
            showSpinner();
            try {
                // No actual API call; inform the user about upcoming availability
                instagramResult.textContent = 'Instagram integration is coming soon.';
                showToast('Instagram integration is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });
        prepareInstagramBtn.addEventListener('click', () => {
            // Show spinner while persisting selected page IDs and max tokens
            showSpinner();
            try {
                // Persist the currently selected Instagram page IDs to localStorage even though
                // the feature is not yet available. This ensures that when Instagram integration
                // goes live, your previous selection is remembered.
                // Persist max tokens and selected Instagram page IDs
                saveMaxTokens();
                getSelectedInstagramPageIds();
                instagramResult.textContent = 'Instagram integration is coming soon.';
                showToast('Instagram integration is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });
        postInstagramBtn.addEventListener('click', () => {
            // Show spinner while persisting selected page IDs and max tokens
            showSpinner();
            try {
                // Persist the currently selected Instagram page IDs before posting.
                // Persist max tokens and selected Instagram page IDs
                saveMaxTokens();
                getSelectedInstagramPageIds();
                instagramResult.textContent = 'Instagram integration is coming soon.';
                showToast('Instagram posting is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });

        // X (Twitter) integration handlers
        // Disable X integration for now. Inform the user and avoid API calls.
        connectXBtn.addEventListener('click', () => {
            // Show spinner briefly for consistent UX
            // Persist current max_tokens for consistency across sessions
            saveMaxTokens();
            showSpinner();
            try {
                xResult.textContent = 'X (Twitter) integration is coming soon.';
                showToast('X (Twitter) integration is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });
        prepareXBtn.addEventListener('click', () => {
            // Show spinner while persisting limits and max tokens
            showSpinner();
            try {
                // Persist X limits and max tokens to localStorage before informing the user.
                saveMaxTokens();
                saveXLimits();
                xResult.textContent = 'X (Twitter) integration is coming soon.';
                showToast('X (Twitter) integration is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });
        postXBtn.addEventListener('click', () => {
            // Show spinner while persisting limits and max tokens
            showSpinner();
            try {
                // Persist X limits and max tokens to localStorage before informing the user.
                saveMaxTokens();
                saveXLimits();
                xResult.textContent = 'X (Twitter) integration is coming soon.';
                showToast('Posting to X is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });

        // Reddit integration handlers
        // Disable Reddit integration for now. Inform the user and avoid API calls.
        connectRedditBtn.addEventListener('click', () => {
            // Show spinner briefly for consistent UX
            // Persist current max_tokens for consistency across sessions
            saveMaxTokens();
            showSpinner();
            try {
                redditResult.textContent = 'Reddit integration is coming soon.';
                showToast('Reddit integration is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });
        prepareRedditBtn.addEventListener('click', () => {
            // Show spinner while persisting limits and max tokens
            showSpinner();
            try {
                // Persist Reddit limits and max tokens to localStorage before informing the user.
                saveMaxTokens();
                saveRedditLimits();
                redditResult.textContent = 'Reddit integration is coming soon.';
                showToast('Reddit integration is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });
        postRedditBtn.addEventListener('click', () => {
            // Show spinner while persisting limits and max tokens
            showSpinner();
            try {
                // Persist Reddit limits and max tokens to localStorage before informing the user.
                saveMaxTokens();
                saveRedditLimits();
                redditResult.textContent = 'Reddit integration is coming soon.';
                showToast('Posting to Reddit is coming soon and is not yet available.', 'info');
            } finally {
                hideSpinner();
            }
        });

        // Failed replies log handlers. These buttons allow the user to view
        // any errors encountered while posting replies and to clear the log.
        if (viewLogsBtn) {
            viewLogsBtn.addEventListener('click', async () => {
                logResult.textContent = '';
                const token = getToken();
                if (!token) {
                    logResult.textContent = 'Please log in to view logs.';
                    showToast('Please log in to view logs.', 'error');
                    return;
                }
                showSpinner();
                try {
                    const response = await fetch(`${API_BASE_URL}/admin/failed_replies`, {
                        headers: { 'Authorization': `Bearer ${token}` },
                    });
                    if (!response.ok) {
                        const errText = await response.text().catch(() => 'Request failed');
                        throw new Error(errText || 'Request failed');
                    }
                    const logs = await response.json();
                    hideSpinner();
                    if (!Array.isArray(logs) || logs.length === 0) {
                        logResult.textContent = 'No failed reply logs found.';
                        showToast('No failed reply logs found.', 'info');
                    } else {
                        logResult.textContent = JSON.stringify(logs, null, 2);
                        showToast('Loaded failed reply logs.', 'success');
                    }
                } catch (error) {
                    hideSpinner();
                    logResult.textContent = `Error: ${error.message}`;
                    showToast(`Error: ${error.message}`, 'error');
                }
            });
        }
        if (clearLogsBtn) {
            clearLogsBtn.addEventListener('click', async () => {
                const token = getToken();
                if (!token) {
                    logResult.textContent = 'Please log in to clear logs.';
                    showToast('Please log in to clear logs.', 'error');
                    return;
                }
                const confirmClear = confirm('Are you sure you want to clear all logs?');
                if (!confirmClear) {
                    return;
                }
                showSpinner();
                try {
                    const response = await fetch(`${API_BASE_URL}/admin/failed_replies`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${token}` },
                    });
                    if (!response.ok) {
                        const errText = await response.text().catch(() => 'Request failed');
                        throw new Error(errText || 'Request failed');
                    }
                    hideSpinner();
                    logResult.textContent = 'Failed reply logs cleared.';
                    showToast('Failed reply logs cleared.', 'success');
                } catch (error) {
                    hideSpinner();
                    logResult.textContent = `Error: ${error.message}`;
                    showToast(`Error: ${error.message}`, 'error');
                }
            });
        }

        // Listen for messages from popup windows indicating that OAuth has completed.
        window.addEventListener('message', (event) => {
            // In a production environment you should verify event.origin to ensure it matches
            // your backend domain. For this MVP we accept messages from any origin.
            const message = event.data;
            if (message === 'facebook_connected' || message === 'instagram_connected' ||
                message === 'x_connected' || message === 'reddit_connected') {
                // Refresh the authenticated UI state. This will hide connect buttons for newly connected platforms.
                updateAuthUI();
                // Provide feedback to the user via a toast.
                showToast('Your account has been connected successfully.', 'success');
            // Check the connection status for Facebook specifically after OAuth completes.
            if (message === 'facebook_connected') {
                checkFacebookConnection();
            }
            }
        });

    // Check whether the current user has already connected a Facebook Page.
    // This helper calls the /admin/facebook_tokens endpoint and inspects the
    // returned list of page tokens. If tokens are present, we disable the
    // connect button and update its label to reflect the connected state.
    async function checkFacebookConnection() {
        const token = getToken();
        // If no auth token is available, we cannot check; leave the connect button enabled
        if (!token) {
            connectFacebookBtn.textContent = 'Connect Facebook';
            connectFacebookBtn.disabled = true;
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/facebook_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                // If one or more page tokens are stored, assume Facebook is connected
                if (Array.isArray(data) && data.length > 0) {
                    connectFacebookBtn.textContent = 'Facebook Connected';
                    connectFacebookBtn.disabled = true;
                } else {
                    // No tokens stored; ensure the button shows connect and is enabled
                    connectFacebookBtn.textContent = 'Connect Facebook';
                    connectFacebookBtn.disabled = false;
                }
            } else {
                // On error, re-enable the button to allow reconnection
                connectFacebookBtn.textContent = 'Connect Facebook';
                connectFacebookBtn.disabled = false;
            }
        } catch (e) {
            connectFacebookBtn.textContent = 'Connect Facebook';
            connectFacebookBtn.disabled = false;
        }
    }
    </script>
</body>
</html>