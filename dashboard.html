<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ReplyFlow Dashboard</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&family=Inter:wght@400;500&display=swap"
        rel="stylesheet"
    />
    <style>
        :root {
            /* Use the same palette as the landing page */
            --primary: #0a84ff;
            --secondary: #32d2ff;
            --accent: #ff6b00;
            --bg: #f7fafc;
            --text-dark: #2d3748;
            --text-medium: #4a5568;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            color: var(--text-dark);
            background-color: var(--bg);
            line-height: 1.6;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        header {
            background-color: var(--primary);
            color: white;
            padding: 1rem;
        }

        header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-family: 'Poppins', sans-serif;
        }

        header nav {
            margin-top: 0.5rem;
        }

        header nav a {
            margin-right: 1rem;
            font-weight: 500;
        }

        main {
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        section {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        section h2 {
            margin-top: 0;
            font-family: 'Poppins', sans-serif;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            resize: vertical;
            padding: 0.5rem;
            font-family: inherit;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
        }

        select,
        button {
            padding: 0.5rem 1rem;
            font-family: inherit;
            font-size: 1rem;
            border-radius: 4px;
            border: 1px solid #cbd5e0;
            margin-right: 0.5rem;
        }

        input[type="email"],
        input[type="password"] {
            padding: 0.5rem;
            font-family: inherit;
            font-size: 1rem;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            display: block;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0066cc;
        }

        pre {
            background-color: #f1f5f9;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Spinner overlay to indicate loading state during async operations */
        #spinner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.75);
            z-index: 9999;
        }

        /* The spinning element itself */
        #spinner::after {
            content: '';
            width: 40px;
            height: 40px;
            border: 4px solid var(--primary);
            border-top: 4px solid var(--secondary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Toast notification for success, error and info messages */
        #toast {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 1rem 1.5rem;
            border-radius: 4px;
            background-color: var(--text-dark);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 10000;
            font-size: 0.875rem;
        }

        #toast.success {
            background-color: #38a169; /* green */
        }

        #toast.error {
            background-color: #e53e3e; /* red */
        }

        #toast.info {
            background-color: var(--primary);
        }
    </style>
</head>
<body>
    <header>
        <h1>ReplyFlow Dashboard</h1>
        <nav>
            <a href="index.html">Home</a>
            <a href="dashboard.html">Dashboard</a>
            <a href="account_settings.html">Account</a>
        </nav>
    </header>
    <main>
        <!-- Authentication Section removed: account management has been moved to its own page -->

        <!-- Generate Reply Section -->
        <section id="generate-section">
            <h2>Generate a Reply</h2>
            <label for="commentInput">Enter a social media comment:</label>
            <textarea id="commentInput" placeholder="Type the comment here..."></textarea>
            <button id="generateBtn">Generate Reply</button>
            <pre id="replyResult"></pre>
        </section>

        <!-- Global reply settings section for choosing tone and max tokens -->
        <section id="reply-settings">
            <h2>Reply Settings</h2>
            <p>Select your desired tone and token limit below. These settings apply to all platforms when preparing or posting replies.</p>
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                <label for="toneSelect" style="margin: 0 0.5rem;">Choose a tone:</label>
                <select id="toneSelect">
                    <option value="friendly">Friendly</option>
                    <option value="focused">Focused</option>
                    <option value="enthusiastic">Enthusiastic</option>
                    <option value="professional">Professional</option>
                    <option value="casual">Casual</option>
                    <option value="apologetic">Apologetic</option>
                    <option value="quirky">Quirky</option>
                    <option value="diplomatic">Diplomatic</option>
                </select>
                <label for="maxTokensInput" style="margin: 0 0.5rem;">Max Tokens:</label>
                <input type="number" id="maxTokensInput" min="1" max="120" value="60" style="width: 4rem;" />
            </div>
        </section>

        <!-- Facebook & Instagram Sharing Section -->
        <section id="fb-share-section">
            <h2>Facebook & Instagram Sharing</h2>
            <p>
                Share your posts to Facebook using the Share dialog or embed your Facebook Page, without requiring any extended permissions.
            </p>
            <div style="margin-bottom: 1rem;">
                <label for="shareUrlInput">URL to share:</label>
                <input type="text" id="shareUrlInput" placeholder="https://example.com" style="width: 100%; padding: 0.5rem;" />
                <button id="shareFacebookBtn" style="margin-top: 0.5rem;">Share on Facebook</button>
            </div>
            <div style="margin-bottom: 1rem;">
                <label for="pageUrlInput">Facebook Page URL to embed:</label>
                <input type="text" id="pageUrlInput" placeholder="https://www.facebook.com/YourPageName" style="width: 100%; padding: 0.5rem;" />
                <button id="embedPageBtn" style="margin-top: 0.5rem;">Embed Page</button>
            </div>
            <div id="pageEmbedContainer"></div>
        </section>

        <!-- X Replies Section -->
        <section id="x-section">
            <h2>X Comment Replies</h2>
            <p>
                Use these controls to fetch recent mentions on X (Twitter), generate AI‑assisted
                draft responses, and optionally post them back. Connect your X account once
                via the button below, then you can prepare and post replies directly from
                this dashboard.
            </p>
            <!-- Display the currently selected tone and max tokens for clarity -->
            <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                Current tone: <strong id="xCurrentTone"></strong> | Max tokens: <strong id="xCurrentTokens"></strong>
            </p>
            <!-- Input controls for max posts and comments -->
            <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                <button id="connectXBtn">Connect X</button>
                <!-- Renamed for clarity: Prepare Replies -> Generate Replies -->
                <button id="prepareXBtn">Generate Replies</button>
                <button id="postXBtn">Post Replies</button>
                <label for="maxPostsXInput" style="margin: 0 0.5rem;">Max Posts:</label>
                <input type="number" id="maxPostsXInput" min="1" value="10" style="width: 4rem;" />
                <label for="maxCommentsXInput" style="margin: 0 0.5rem;">Max Comments:</label>
                <input type="number" id="maxCommentsXInput" min="1" value="20" style="width: 4rem;" />
            </div>
            <pre id="xResult"></pre>
        </section>

        <!-- Reddit Replies Section -->
        <section id="reddit-section">
            <h2>Reddit Comment Replies</h2>
            <p>
                Use these controls to fetch recent comments or mentions on your Reddit posts,
                generate AI‑drafted responses, and post them back. You will need to
                connect your Reddit account once using the button below. After connecting,
                you can prepare and publish replies right from this dashboard.
            </p>
            <!-- Display the currently selected tone and max tokens for clarity -->
            <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                Current tone: <strong id="redditCurrentTone"></strong> | Max tokens: <strong id="redditCurrentTokens"></strong>
            </p>
            <!-- Input controls for max posts and comments -->
            <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                <button id="connectRedditBtn">Connect Reddit</button>
                <!-- Renamed for clarity: Prepare Replies -> Generate Replies -->
                <button id="prepareRedditBtn">Generate Replies</button>
                <button id="postRedditBtn">Post Replies</button>
                <label for="maxPostsRedditInput" style="margin: 0 0.5rem;">Max Posts:</label>
                <input type="number" id="maxPostsRedditInput" min="1" value="10" style="width: 4rem;" />
                <label for="maxCommentsRedditInput" style="margin: 0 0.5rem;">Max Comments:</label>
                <input type="number" id="maxCommentsRedditInput" min="1" value="20" style="width: 4rem;" />
            </div>
            <pre id="redditResult"></pre>
        </section>

          <!-- Bluesky Replies Section -->
          <section id="bluesky-section">
              <h2>Bluesky Comment Replies</h2>
              <p>
                  Use these controls to fetch recent posts or mentions on Bluesky, generate AI‑drafted
                  responses, and optionally post them back. Connect your Bluesky account once using the button below. After connecting,
                  you can prepare and publish replies right from this dashboard.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="blueskyCurrentTone"></strong> | Max tokens: <strong id="blueskyCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectBlueskyBtn">Connect Bluesky</button>
                  <button id="prepareBlueskyBtn">Generate Replies</button>
                  <button id="postBlueskyBtn">Post Replies</button>
                  <label for="maxPostsBlueskyInput" style="margin: 0 0.5rem;">Max Posts:</label>
                  <input type="number" id="maxPostsBlueskyInput" min="1" value="10" style="width: 4rem;" />
                  <label for="maxCommentsBlueskyInput" style="margin: 0 0.5rem;">Max Comments:</label>
                  <input type="number" id="maxCommentsBlueskyInput" min="1" value="20" style="width: 4rem;" />
              </div>
              <pre id="blueskyResult"></pre>
          </section>

          <!-- LinkedIn Replies Section -->
          <section id="linkedin-section">
              <h2>LinkedIn Comment Replies</h2>
              <p>
                  Use these controls to fetch recent comments or mentions on your LinkedIn posts,
                  generate AI‑drafted responses, and post them back. You will need to connect your
                  LinkedIn account once using the button below. After connecting, you can prepare and publish replies right from this dashboard.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="linkedinCurrentTone"></strong> | Max tokens: <strong id="linkedinCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectLinkedinBtn">Connect LinkedIn</button>
                  <button id="prepareLinkedinBtn">Generate Replies</button>
                  <button id="postLinkedinBtn">Post Replies</button>
                  <label for="maxPostsLinkedinInput" style="margin: 0 0.5rem;">Max Posts:</label>
                  <input type="number" id="maxPostsLinkedinInput" min="1" value="10" style="width: 4rem;" />
                  <label for="maxCommentsLinkedinInput" style="margin: 0 0.5rem;">Max Comments:</label>
                  <input type="number" id="maxCommentsLinkedinInput" min="1" value="20" style="width: 4rem;" />
              </div>
              <pre id="linkedinResult"></pre>
          </section>

          <!-- Google Review Replies Section -->
          <section id="google-section">
              <h2>Google Review Replies</h2>
              <p>
                  Use these controls to fetch recent Google reviews for your business locations,
                  generate AI‑drafted responses, and optionally post them back. Connect your
                  Google Business Profile account once using the button below. After connecting,
                  you can prepare and publish replies right from this dashboard.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="googleCurrentTone"></strong> | Max tokens: <strong id="googleCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectGoogleBtn">Connect Google</button>
                  <button id="prepareGoogleBtn">Generate Replies</button>
                  <button id="postGoogleBtn">Post Replies</button>
                  <label for="maxPostsGoogleInput" style="margin: 0 0.5rem;">Max Reviews:</label>
                  <input type="number" id="maxPostsGoogleInput" min="1" value="10" style="width: 4rem;" />
                  <label for="maxCommentsGoogleInput" style="margin: 0 0.5rem;">Max Comments:</label>
                  <input type="number" id="maxCommentsGoogleInput" min="1" value="20" style="width: 4rem;" />
              </div>
              <pre id="googleResult"></pre>
          </section>

          <!-- Telegram Replies Section -->
          <section id="telegram-section">
              <h2>Telegram Bot Replies</h2>
              <p>
                  Use these controls to fetch messages sent to your Telegram bot and generate
                  AI‑assisted responses. Connect your Telegram bot token once using the button below.
                  After connecting, you can prepare and post replies directly from this dashboard.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="telegramCurrentTone"></strong> | Max tokens: <strong id="telegramCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectTelegramBtn">Connect Telegram</button>
                  <button id="prepareTelegramBtn">Generate Replies</button>
                  <button id="postTelegramBtn">Post Replies</button>
                  <label for="maxPostsTelegramInput" style="margin: 0 0.5rem;">Max Messages:</label>
                  <input type="number" id="maxPostsTelegramInput" min="1" value="10" style="width: 4rem;" />
                  <label for="maxCommentsTelegramInput" style="margin: 0 0.5rem;">Max Replies:</label>
                  <input type="number" id="maxCommentsTelegramInput" min="1" value="20" style="width: 4rem;" />
              </div>
              <pre id="telegramResult"></pre>
          </section>

          <!-- Threads Replies Section -->
          <section id="threads-section">
              <h2>Threads Replies</h2>
              <p>
                  Use these controls to fetch recent replies to your Threads posts, generate AI‑drafted responses,
                  and optionally post them back. Connect your Threads account once using the button below.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="threadsCurrentTone"></strong> | Max tokens: <strong id="threadsCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectThreadsBtn">Connect Threads</button>
                  <button id="prepareThreadsBtn">Generate Replies</button>
                  <button id="postThreadsBtn">Post Replies</button>
                  <label for="maxPostsThreadsInput" style="margin: 0 0.5rem;">Max Posts:</label>
                  <input type="number" id="maxPostsThreadsInput" min="1" value="10" style="width: 4rem;" />
                  <label for="maxCommentsThreadsInput" style="margin: 0 0.5rem;">Max Comments:</label>
                  <input type="number" id="maxCommentsThreadsInput" min="1" value="20" style="width: 4rem;" />
              </div>
              <pre id="threadsResult"></pre>
          </section>

          <!-- YouTube Replies Section -->
          <section id="youtube-section">
              <h2>YouTube Comment Replies</h2>
              <p>
                  Use these controls to fetch recent comments on your YouTube videos, generate AI‑drafted responses,
                  and optionally post them back. Connect your YouTube account once using the button below.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="youtubeCurrentTone"></strong> | Max tokens: <strong id="youtubeCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectYoutubeBtn">Connect YouTube</button>
                  <button id="prepareYoutubeBtn">Generate Replies</button>
                  <button id="postYoutubeBtn">Post Replies</button>
                  <label for="maxPostsYoutubeInput" style="margin: 0 0.5rem;">Max Videos:</label>
                  <input type="number" id="maxPostsYoutubeInput" min="1" value="10" style="width: 4rem;" />
                  <label for="maxCommentsYoutubeInput" style="margin: 0 0.5rem;">Max Comments:</label>
                  <input type="number" id="maxCommentsYoutubeInput" min="1" value="20" style="width: 4rem;" />
              </div>
              <pre id="youtubeResult"></pre>
          </section>

          <!-- Pinterest Analytics Section -->
          <section id="pinterest-section">
              <h2>Pinterest Analytics</h2>
              <p>
                  Automated replies are not supported for Pinterest. At this time, ReplyFlow can only
                  provide basic analytics or scheduling features for your pins (if available). To
                  respond to comments on Pinterest, you will need to do so manually on the platform.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="pinterestCurrentTone"></strong> | Max tokens: <strong id="pinterestCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectPinterestBtn">Connect Pinterest</button>
                  <button id="analyzePinterestBtn">Fetch Analytics</button>
              </div>
              <pre id="pinterestResult"></pre>
          </section>

          <!-- Snapchat Analytics Section -->
          <section id="snapchat-section">
              <h2>Snapchat Analytics</h2>
              <p>
                  Snapchat does not provide an API for replying to story or chat messages. ReplyFlow
                  supports limited analytics (such as views or reach where available), but any
                  responses must be made manually within Snapchat.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="snapchatCurrentTone"></strong> | Max tokens: <strong id="snapchatCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectSnapchatBtn">Connect Snapchat</button>
                  <button id="analyzeSnapchatBtn">Fetch Analytics</button>
              </div>
              <pre id="snapchatResult"></pre>
          </section>

          <!-- TikTok Comment Analysis Section -->
          <section id="tiktok-section">
              <h2>TikTok Comment Analysis</h2>
              <p>
                  Using TikTok’s Research API, ReplyFlow can analyze comments on your videos to
                  surface insights such as sentiment and top questions. However, the API does
                  not allow automated replies; you will need to respond manually on TikTok.
              </p>
              <p style="font-size: 0.875rem; color: var(--text-medium); margin-bottom: 0.5rem;">
                  Current tone: <strong id="tiktokCurrentTone"></strong> | Max tokens: <strong id="tiktokCurrentTokens"></strong>
              </p>
              <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                  <button id="connectTiktokBtn">Connect TikTok</button>
                  <button id="analyzeTiktokBtn">Analyze Comments</button>
              </div>
              <pre id="tiktokResult"></pre>
          </section>

        <!-- Failed Replies Log Section -->
        <section id="log-section">
            <h2>Failed Replies Log</h2>
            <p>
                View errors encountered while posting replies to social platforms. Use this
                tool to debug why certain replies couldn't be posted. You can also
                clear the log after reviewing it. Logs are stored only in memory and
                are not persisted across server restarts.
            </p>
            <div style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
                <button id="viewLogsBtn">View Logs</button>
                <button id="clearLogsBtn">Clear Logs</button>
            </div>
            <pre id="logResult"></pre>
        </section>
    </main>
    <!-- Global spinner overlay and toast notification elements -->
    <div id="spinner"></div>
    <div id="toast" class="toast"></div>
    <script>
        // Base URL for the API. If your backend runs on another host or port, change this.
        // Set your backend API base URL. For local development, use http://127.0.0.1:8000
        // If your backend is hosted on a different domain, update this value accordingly.
        // Base URL for the backend API. Updated to point to the deployed Render service.
        const API_BASE_URL = 'https://replyflow-mvp-backend.onrender.com';

        // Immediately redirect unauthenticated users to the login page. If no
        // token is present in localStorage, we should not allow access to
        // the dashboard. A wrapper is used so the check runs as soon as
        // possible before other logic executes.
        (function() {
            try {
                const token = localStorage.getItem('replyflow_token');
                if (!token) {
                    // Redirect to the dedicated account (login) page when unauthenticated.
                    window.location.href = 'account.html';
                }
            } catch (e) {
                // If localStorage access fails for any reason, redirect to the account (login) page anyway
                window.location.href = 'account.html';
            }
        })();

        const commentInput = document.getElementById('commentInput');
        const toneSelect = document.getElementById('toneSelect');
        const generateBtn = document.getElementById('generateBtn');
        const replyResult = document.getElementById('replyResult');

        // Inputs and buttons for the Facebook/Instagram share section.  These elements allow
        // users to enter a URL to share or a Facebook Page URL to embed.  Unlike the
        // previous comment reply integration, this lightweight approach does not
        // require connecting a Facebook account or storing tokens.
        const shareUrlInput = document.getElementById('shareUrlInput');
        const shareFacebookBtn = document.getElementById('shareFacebookBtn');
        const pageUrlInput = document.getElementById('pageUrlInput');
        const embedPageBtn = document.getElementById('embedPageBtn');
        const pageEmbedContainer = document.getElementById('pageEmbedContainer');

        // Update tone display when the tone or max tokens change
        if (toneSelect) {
            toneSelect.addEventListener('change', updateToneDisplays);
        }
        if (maxTokensInput) {
            maxTokensInput.addEventListener('change', updateToneDisplays);
        }

        const prepareBtn = document.getElementById('prepareBtn');
        const postBtn = document.getElementById('postBtn');
        const facebookResult = document.getElementById('facebookResult');
        const connectFacebookBtn = document.getElementById('connectFacebookBtn');

        // Per‑page limit inputs for Facebook
        const maxPostsInput = document.getElementById('maxPostsInput');
        const maxCommentsInput = document.getElementById('maxCommentsInput');

        // Global input for limiting the number of tokens per reply
        const maxTokensInput = document.getElementById('maxTokensInput');

        /**
         * Load saved max_tokens value from localStorage and apply it to the
         * maxTokensInput. If a saved value exists within the 1–120 range, it
         * will be set on the input. Otherwise the default value remains.
         */
        function loadMaxTokens() {
            try {
                const saved = localStorage.getItem('reply_max_tokens');
                const val = parseInt(saved);
                if (!isNaN(val) && val >= 1 && val <= 120) {
                    maxTokensInput.value = val;
                }
            } catch (e) {
                // ignore any errors
            }
        }

        /**
         * Persist the current value of maxTokensInput to localStorage. Only
         * values within the valid range (1–120) are stored.
         */
        function saveMaxTokens() {
            const val = parseInt(maxTokensInput.value);
            if (!isNaN(val) && val >= 1 && val <= 120) {
                try {
                    localStorage.setItem('reply_max_tokens', val.toString());
                } catch (e) {
                    // ignore storage errors
                }
            }
        }

        // Facebook page selector elements (multi-select) and label
        const fbPageSelect = document.getElementById('fbPageSelect');
        const fbPageSelectLabel = document.getElementById('fbPageSelectLabel');

        /**
         * Load the list of connected Facebook pages and populate the multi-select.
         * This function calls the /admin/facebook_pages endpoint to retrieve
         * page IDs and names. It then shows the selector only if more than
         * one page is available. Previously selected pages (stored in
         * localStorage under 'fb_selected_pages') are automatically
         * pre‑selected.
         */
        async function loadFacebookPages() {
            const token = getToken();
            // If no token or no fetch API, hide the selector and return
            if (!token) {
                fbPageSelect.style.display = 'none';
                fbPageSelectLabel.style.display = 'none';
                return;
            }
            try {
                const res = await fetch(`${API_BASE_URL}/admin/facebook_pages`, {
                    headers: { 'Authorization': `Bearer ${token}` },
                });
                if (!res.ok) {
                    fbPageSelect.style.display = 'none';
                    fbPageSelectLabel.style.display = 'none';
                    return;
                }
                const pages = await res.json();
                if (!Array.isArray(pages) || pages.length === 0) {
                    fbPageSelect.style.display = 'none';
                    fbPageSelectLabel.style.display = 'none';
                    return;
                }
                // Clear any existing options
                fbPageSelect.innerHTML = '';
                // Retrieve previously selected pages from localStorage
                let savedIds = [];
                try {
                    const saved = localStorage.getItem('fb_selected_pages');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed)) {
                            savedIds = parsed;
                        }
                    }
                } catch (e) {
                    savedIds = [];
                }
                // Populate options and pre-select saved ones
                pages.forEach((page) => {
                    const opt = document.createElement('option');
                    opt.value = page.id;
                    opt.textContent = page.name;
                    if (savedIds.includes(page.id)) {
                        opt.selected = true;
                    }
                    fbPageSelect.appendChild(opt);
                });
                // Show or hide the selector based on number of pages
                if (pages.length > 1) {
                    fbPageSelect.style.display = '';
                    fbPageSelectLabel.style.display = '';
                } else {
                    fbPageSelect.style.display = 'none';
                    fbPageSelectLabel.style.display = 'none';
                }
            } catch (e) {
                fbPageSelect.style.display = 'none';
                fbPageSelectLabel.style.display = 'none';
            }
        }

        /**
         * Retrieve currently selected Facebook page IDs from the multi-select.
         * The selected IDs are stored in localStorage (fb_selected_pages) so
         * they can be restored on future visits. Returns an array of
         * selected IDs. If no selector exists or no options are selected,
         * returns an empty array.
         */
        function getSelectedPageIds() {
            const select = fbPageSelect;
            if (!select || select.style.display === 'none') {
                return [];
            }
            const selected = Array.from(select.options)
                .filter((opt) => opt.selected)
                .map((opt) => opt.value);
            try {
                localStorage.setItem('fb_selected_pages', JSON.stringify(selected));
            } catch (e) {
                // Ignore storage errors (e.g., quota exceeded)
            }
            return selected;
        }

        /**
         * Load Instagram pages/accounts and populate the IG page selector.
         * This mirrors loadFacebookPages but stores selections under
         * 'ig_selected_pages' in localStorage. It fetches the same list
         * of connected Facebook pages because Instagram accounts are
         * associated with the Facebook Page tokens. If more than one
         * page/account exists, the selector is shown; otherwise it remains
         * hidden.
         */
        async function loadInstagramPages() {
            const token = getToken();
            if (!token) {
                igPageSelect.style.display = 'none';
                igPageSelectLabel.style.display = 'none';
                return;
            }
            try {
                const res = await fetch(`${API_BASE_URL}/admin/facebook_pages`, {
                    headers: { 'Authorization': `Bearer ${token}` },
                });
                if (!res.ok) {
                    igPageSelect.style.display = 'none';
                    igPageSelectLabel.style.display = 'none';
                    return;
                }
                const pages = await res.json();
                if (!Array.isArray(pages) || pages.length === 0) {
                    igPageSelect.style.display = 'none';
                    igPageSelectLabel.style.display = 'none';
                    return;
                }
                igPageSelect.innerHTML = '';
                let savedIds = [];
                try {
                    const saved = localStorage.getItem('ig_selected_pages');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed)) {
                            savedIds = parsed;
                        }
                    }
                } catch (e) {
                    savedIds = [];
                }
                pages.forEach((page) => {
                    const opt = document.createElement('option');
                    opt.value = page.id;
                    opt.textContent = page.name;
                    if (savedIds.includes(page.id)) {
                        opt.selected = true;
                    }
                    igPageSelect.appendChild(opt);
                });
                if (pages.length > 1) {
                    igPageSelect.style.display = '';
                    igPageSelectLabel.style.display = '';
                } else {
                    igPageSelect.style.display = 'none';
                    igPageSelectLabel.style.display = 'none';
                }
            } catch (e) {
                igPageSelect.style.display = 'none';
                igPageSelectLabel.style.display = 'none';
            }
        }

        /**
         * Retrieve selected Instagram page IDs and persist them to localStorage.
         * Returns an array of selected page IDs. If the selector is hidden or
         * undefined, returns an empty array.
         */
        function getSelectedInstagramPageIds() {
            const select = igPageSelect;
            if (!select || select.style.display === 'none') {
                return [];
            }
            const selected = Array.from(select.options)
                .filter((opt) => opt.selected)
                .map((opt) => opt.value);
            try {
                localStorage.setItem('ig_selected_pages', JSON.stringify(selected));
            } catch (e) {}
            return selected;
        }

        // Instagram elements
        const connectInstagramBtn = document.getElementById('connectInstagramBtn');
        const prepareInstagramBtn = document.getElementById('prepareInstagramBtn');
        const postInstagramBtn = document.getElementById('postInstagramBtn');
        const instagramResult = document.getElementById('instagramResult');

        // Instagram per‑page limit inputs
        const maxPostsInstagramInput = document.getElementById('maxPostsInstagramInput');
        const maxCommentsInstagramInput = document.getElementById('maxCommentsInstagramInput');

        // Instagram page selector elements and label (for multi-account/page support)
        const igPageSelect = document.getElementById('igPageSelect');
        const igPageSelectLabel = document.getElementById('igPageSelectLabel');

        // X (Twitter) elements
        const connectXBtn = document.getElementById('connectXBtn');
        const prepareXBtn = document.getElementById('prepareXBtn');
        const postXBtn = document.getElementById('postXBtn');
        const xResult = document.getElementById('xResult');

        // X per‑page limit inputs
        const maxPostsXInput = document.getElementById('maxPostsXInput');
        const maxCommentsXInput = document.getElementById('maxCommentsXInput');

        // Reddit elements
        const connectRedditBtn = document.getElementById('connectRedditBtn');
        const prepareRedditBtn = document.getElementById('prepareRedditBtn');
        const postRedditBtn = document.getElementById('postRedditBtn');
        const redditResult = document.getElementById('redditResult');

        // Reddit per‑page limit inputs
        const maxPostsRedditInput = document.getElementById('maxPostsRedditInput');
        const maxCommentsRedditInput = document.getElementById('maxCommentsRedditInput');

          // Bluesky elements
          const connectBlueskyBtn = document.getElementById('connectBlueskyBtn');
          const prepareBlueskyBtn = document.getElementById('prepareBlueskyBtn');
          const postBlueskyBtn = document.getElementById('postBlueskyBtn');
          const blueskyResult = document.getElementById('blueskyResult');
          const maxPostsBlueskyInput = document.getElementById('maxPostsBlueskyInput');
          const maxCommentsBlueskyInput = document.getElementById('maxCommentsBlueskyInput');

          // LinkedIn elements
          const connectLinkedinBtn = document.getElementById('connectLinkedinBtn');
          const prepareLinkedinBtn = document.getElementById('prepareLinkedinBtn');
          const postLinkedinBtn = document.getElementById('postLinkedinBtn');
          const linkedinResult = document.getElementById('linkedinResult');
          const maxPostsLinkedinInput = document.getElementById('maxPostsLinkedinInput');
          const maxCommentsLinkedinInput = document.getElementById('maxCommentsLinkedinInput');

          // Google elements
          const connectGoogleBtn = document.getElementById('connectGoogleBtn');
          const prepareGoogleBtn = document.getElementById('prepareGoogleBtn');
          const postGoogleBtn = document.getElementById('postGoogleBtn');
          const googleResult = document.getElementById('googleResult');
          const maxPostsGoogleInput = document.getElementById('maxPostsGoogleInput');
          const maxCommentsGoogleInput = document.getElementById('maxCommentsGoogleInput');

          // Telegram elements
          const connectTelegramBtn = document.getElementById('connectTelegramBtn');
          const prepareTelegramBtn = document.getElementById('prepareTelegramBtn');
          const postTelegramBtn = document.getElementById('postTelegramBtn');
          const telegramResult = document.getElementById('telegramResult');
          const maxPostsTelegramInput = document.getElementById('maxPostsTelegramInput');
          const maxCommentsTelegramInput = document.getElementById('maxCommentsTelegramInput');

          // Threads elements
          const connectThreadsBtn = document.getElementById('connectThreadsBtn');
          const prepareThreadsBtn = document.getElementById('prepareThreadsBtn');
          const postThreadsBtn = document.getElementById('postThreadsBtn');
          const threadsResult = document.getElementById('threadsResult');
          const maxPostsThreadsInput = document.getElementById('maxPostsThreadsInput');
          const maxCommentsThreadsInput = document.getElementById('maxCommentsThreadsInput');

          // YouTube elements
          const connectYoutubeBtn = document.getElementById('connectYoutubeBtn');
          const prepareYoutubeBtn = document.getElementById('prepareYoutubeBtn');
          const postYoutubeBtn = document.getElementById('postYoutubeBtn');
          const youtubeResult = document.getElementById('youtubeResult');
          const maxPostsYoutubeInput = document.getElementById('maxPostsYoutubeInput');
          const maxCommentsYoutubeInput = document.getElementById('maxCommentsYoutubeInput');

          // Pinterest elements
          const connectPinterestBtn = document.getElementById('connectPinterestBtn');
          const analyzePinterestBtn = document.getElementById('analyzePinterestBtn');
          const pinterestResult = document.getElementById('pinterestResult');

          // Snapchat elements
          const connectSnapchatBtn = document.getElementById('connectSnapchatBtn');
          const analyzeSnapchatBtn = document.getElementById('analyzeSnapchatBtn');
          const snapchatResult = document.getElementById('snapchatResult');

          // TikTok elements
          const connectTiktokBtn = document.getElementById('connectTiktokBtn');
          const analyzeTiktokBtn = document.getElementById('analyzeTiktokBtn');
          const tiktokResult = document.getElementById('tiktokResult');

        // Failed replies log elements
        const viewLogsBtn = document.getElementById('viewLogsBtn');
        const clearLogsBtn = document.getElementById('clearLogsBtn');
        const logResult = document.getElementById('logResult');

        // Spinner and toast elements. The spinner shows a loading overlay during async actions.
        // The toast displays brief notifications (success, error, info) to the user.
        const spinner = document.getElementById('spinner');
        const toastEl = document.getElementById('toast');

        /**
         * Show the spinner overlay. Call this before starting an async operation.
         */
        function showSpinner() {
            if (spinner) {
                spinner.style.display = 'flex';
            }
        }

        /**
         * Hide the spinner overlay. Call this after an async operation completes.
         */
        function hideSpinner() {
            if (spinner) {
                spinner.style.display = 'none';
            }
        }

        /**
         * Display a toast notification with a message and optional type.
         * Type can be 'success', 'error' or 'info' which affects the color.
         * The toast automatically hides after 3 seconds.
         * @param {string} message The message to display
         * @param {string} [type='info'] The type of toast (success, error, info)
         */
        function showToast(message, type = 'info') {
            if (!toastEl) return;
            // Reset existing classes
            toastEl.className = 'toast';
            if (type === 'success' || type === 'error' || type === 'info') {
                toastEl.classList.add(type);
            }
            toastEl.textContent = message;
            toastEl.style.display = 'block';
            // Hide after 3 seconds
            setTimeout(() => {
                toastEl.style.display = 'none';
                toastEl.className = 'toast';
            }, 3000);
        }

        /**
         * Update the displayed current tone and token limit in each platform section. This
         * helps users understand which tone and max token values will be used when
         * generating and posting replies. The displays are defined in each platform
         * section (fbCurrentTone, fbCurrentTokens, igCurrentTone, igCurrentTokens, etc.).
         */
        function updateToneDisplays() {
            const tone = toneSelect?.value || '';
            const tokens = maxTokensInput?.value || '';
            // Update Facebook display
            const fbToneEl = document.getElementById('fbCurrentTone');
            const fbTokensEl = document.getElementById('fbCurrentTokens');
            if (fbToneEl) fbToneEl.textContent = tone;
            if (fbTokensEl) fbTokensEl.textContent = tokens;
            // Update Instagram display
            const igToneEl = document.getElementById('igCurrentTone');
            const igTokensEl = document.getElementById('igCurrentTokens');
            if (igToneEl) igToneEl.textContent = tone;
            if (igTokensEl) igTokensEl.textContent = tokens;
            // Update X (Twitter) display
            const xToneEl = document.getElementById('xCurrentTone');
            const xTokensEl = document.getElementById('xCurrentTokens');
            if (xToneEl) xToneEl.textContent = tone;
            if (xTokensEl) xTokensEl.textContent = tokens;
            // Update Reddit display
            const redditToneEl = document.getElementById('redditCurrentTone');
            const redditTokensEl = document.getElementById('redditCurrentTokens');
            if (redditToneEl) redditToneEl.textContent = tone;
            if (redditTokensEl) redditTokensEl.textContent = tokens;
            // Update Bluesky display
            const blueskyToneEl = document.getElementById('blueskyCurrentTone');
            const blueskyTokensEl = document.getElementById('blueskyCurrentTokens');
            if (blueskyToneEl) blueskyToneEl.textContent = tone;
            if (blueskyTokensEl) blueskyTokensEl.textContent = tokens;
            // Update LinkedIn display
            const linkedinToneEl = document.getElementById('linkedinCurrentTone');
            const linkedinTokensEl = document.getElementById('linkedinCurrentTokens');
            if (linkedinToneEl) linkedinToneEl.textContent = tone;
            if (linkedinTokensEl) linkedinTokensEl.textContent = tokens;
            // Update Google display
            const googleToneEl = document.getElementById('googleCurrentTone');
            const googleTokensEl = document.getElementById('googleCurrentTokens');
            if (googleToneEl) googleToneEl.textContent = tone;
            if (googleTokensEl) googleTokensEl.textContent = tokens;
            // Update Telegram display
            const telegramToneEl = document.getElementById('telegramCurrentTone');
            const telegramTokensEl = document.getElementById('telegramCurrentTokens');
            if (telegramToneEl) telegramToneEl.textContent = tone;
            if (telegramTokensEl) telegramTokensEl.textContent = tokens;
            // Update Threads display
            const threadsToneEl = document.getElementById('threadsCurrentTone');
            const threadsTokensEl = document.getElementById('threadsCurrentTokens');
            if (threadsToneEl) threadsToneEl.textContent = tone;
            if (threadsTokensEl) threadsTokensEl.textContent = tokens;
            // Update YouTube display
            const youtubeToneEl = document.getElementById('youtubeCurrentTone');
            const youtubeTokensEl = document.getElementById('youtubeCurrentTokens');
            if (youtubeToneEl) youtubeToneEl.textContent = tone;
            if (youtubeTokensEl) youtubeTokensEl.textContent = tokens;

            // Update Pinterest display
            const pinterestToneEl = document.getElementById('pinterestCurrentTone');
            const pinterestTokensEl = document.getElementById('pinterestCurrentTokens');
            if (pinterestToneEl) pinterestToneEl.textContent = tone;
            if (pinterestTokensEl) pinterestTokensEl.textContent = tokens;

            // Update Snapchat display
            const snapchatToneEl = document.getElementById('snapchatCurrentTone');
            const snapchatTokensEl = document.getElementById('snapchatCurrentTokens');
            if (snapchatToneEl) snapchatToneEl.textContent = tone;
            if (snapchatTokensEl) snapchatTokensEl.textContent = tokens;

            // Update TikTok display
            const tiktokToneEl = document.getElementById('tiktokCurrentTone');
            const tiktokTokensEl = document.getElementById('tiktokCurrentTokens');
            if (tiktokToneEl) tiktokToneEl.textContent = tone;
            if (tiktokTokensEl) tiktokTokensEl.textContent = tokens;
        }

        /**
         * Persist the current X (Twitter) limits (max posts/comments) to localStorage.
         * These values are used to restore the user's last selection on reload.
         */
        function saveXLimits() {
            try {
                localStorage.setItem('x_max_posts', maxPostsXInput.value);
                localStorage.setItem('x_max_comments', maxCommentsXInput.value);
            } catch (e) {
                // Ignore storage errors
            }
        }

        /**
         * Load saved X (Twitter) limits from localStorage and apply them to the inputs.
         */
        function loadXLimits() {
            try {
                const mp = localStorage.getItem('x_max_posts');
                const mc = localStorage.getItem('x_max_comments');
                if (mp !== null) {
                    maxPostsXInput.value = mp;
                }
                if (mc !== null) {
                    maxCommentsXInput.value = mc;
                }
            } catch (e) {
                // Ignore errors
            }
        }

        /**
         * Persist the current Reddit limits (max posts/comments) to localStorage.
         */
        function saveRedditLimits() {
            try {
                localStorage.setItem('reddit_max_posts', maxPostsRedditInput.value);
                localStorage.setItem('reddit_max_comments', maxCommentsRedditInput.value);
            } catch (e) {}
        }

        /**
         * Load saved Reddit limits from localStorage and apply them to the inputs.
         */
        function loadRedditLimits() {
            try {
                const mp = localStorage.getItem('reddit_max_posts');
                const mc = localStorage.getItem('reddit_max_comments');
                if (mp !== null) {
                    maxPostsRedditInput.value = mp;
                }
                if (mc !== null) {
                    maxCommentsRedditInput.value = mc;
                }
            } catch (e) {}
        }

        // Persist the current Bluesky limits to localStorage
        function saveBlueskyLimits() {
            try {
                localStorage.setItem('bluesky_max_posts', maxPostsBlueskyInput?.value || '');
                localStorage.setItem('bluesky_max_comments', maxCommentsBlueskyInput?.value || '');
            } catch (e) {}
        }
        // Load saved Bluesky limits from localStorage
        function loadBlueskyLimits() {
            try {
                const mp = localStorage.getItem('bluesky_max_posts');
                const mc = localStorage.getItem('bluesky_max_comments');
                if (mp !== null && maxPostsBlueskyInput) {
                    maxPostsBlueskyInput.value = mp;
                }
                if (mc !== null && maxCommentsBlueskyInput) {
                    maxCommentsBlueskyInput.value = mc;
                }
            } catch (e) {}
        }

        // Persist the current LinkedIn limits to localStorage
        function saveLinkedinLimits() {
            try {
                localStorage.setItem('linkedin_max_posts', maxPostsLinkedinInput?.value || '');
                localStorage.setItem('linkedin_max_comments', maxCommentsLinkedinInput?.value || '');
            } catch (e) {}
        }
        // Load saved LinkedIn limits from localStorage
        function loadLinkedinLimits() {
            try {
                const mp = localStorage.getItem('linkedin_max_posts');
                const mc = localStorage.getItem('linkedin_max_comments');
                if (mp !== null && maxPostsLinkedinInput) {
                    maxPostsLinkedinInput.value = mp;
                }
                if (mc !== null && maxCommentsLinkedinInput) {
                    maxCommentsLinkedinInput.value = mc;
                }
            } catch (e) {}
        }

        // Persist the current Google limits to localStorage
        function saveGoogleLimits() {
            try {
                localStorage.setItem('google_max_posts', maxPostsGoogleInput?.value || '');
                localStorage.setItem('google_max_comments', maxCommentsGoogleInput?.value || '');
            } catch (e) {}
        }
        // Load saved Google limits from localStorage
        function loadGoogleLimits() {
            try {
                const mp = localStorage.getItem('google_max_posts');
                const mc = localStorage.getItem('google_max_comments');
                if (mp !== null && maxPostsGoogleInput) {
                    maxPostsGoogleInput.value = mp;
                }
                if (mc !== null && maxCommentsGoogleInput) {
                    maxCommentsGoogleInput.value = mc;
                }
            } catch (e) {}
        }

        // Persist the current Telegram limits to localStorage
        function saveTelegramLimits() {
            try {
                localStorage.setItem('telegram_max_posts', maxPostsTelegramInput?.value || '');
                localStorage.setItem('telegram_max_comments', maxCommentsTelegramInput?.value || '');
            } catch (e) {}
        }
        // Load saved Telegram limits from localStorage
        function loadTelegramLimits() {
            try {
                const mp = localStorage.getItem('telegram_max_posts');
                const mc = localStorage.getItem('telegram_max_comments');
                if (mp !== null && maxPostsTelegramInput) {
                    maxPostsTelegramInput.value = mp;
                }
                if (mc !== null && maxCommentsTelegramInput) {
                    maxCommentsTelegramInput.value = mc;
                }
            } catch (e) {}
        }

        // Persist the current Threads limits to localStorage
        function saveThreadsLimits() {
            try {
                localStorage.setItem('threads_max_posts', maxPostsThreadsInput?.value || '');
                localStorage.setItem('threads_max_comments', maxCommentsThreadsInput?.value || '');
            } catch (e) {}
        }
        // Load saved Threads limits from localStorage
        function loadThreadsLimits() {
            try {
                const mp = localStorage.getItem('threads_max_posts');
                const mc = localStorage.getItem('threads_max_comments');
                if (mp !== null && maxPostsThreadsInput) {
                    maxPostsThreadsInput.value = mp;
                }
                if (mc !== null && maxCommentsThreadsInput) {
                    maxCommentsThreadsInput.value = mc;
                }
            } catch (e) {}
        }

        // Persist the current YouTube limits to localStorage
        function saveYoutubeLimits() {
            try {
                localStorage.setItem('youtube_max_posts', maxPostsYoutubeInput?.value || '');
                localStorage.setItem('youtube_max_comments', maxCommentsYoutubeInput?.value || '');
            } catch (e) {}
        }
        // Load saved YouTube limits from localStorage
        function loadYoutubeLimits() {
            try {
                const mp = localStorage.getItem('youtube_max_posts');
                const mc = localStorage.getItem('youtube_max_comments');
                if (mp !== null && maxPostsYoutubeInput) {
                    maxPostsYoutubeInput.value = mp;
                }
                if (mc !== null && maxCommentsYoutubeInput) {
                    maxCommentsYoutubeInput.value = mc;
                }
            } catch (e) {}
        }

        // Auth elements
        // Authentication elements removed from dashboard. These variables remain undefined
        // because account management is now handled on the dedicated account_settings page.
        const signupEmail = null;
        const signupPassword = null;
        const signupBtn = null;
        const loginEmail = null;
        const loginPassword = null;
        const loginBtn = null;
        const authMessage = null;
        const userInfo = null;
        const userEmail = null;
        const userPlan = null;
        const logoutBtn = null;
        // Subscription management elements removed
        const subscriptionActions = null;
        const manageSubBtn = null;
        const cancelSubBtn = null;

        // Helper to get auth token from localStorage
        function getToken() {
            return localStorage.getItem('replyflow_token');
        }

        // Save token to localStorage
        function setToken(token) {
            localStorage.setItem('replyflow_token', token);
        }

        // Remove token
        function clearToken() {
            localStorage.removeItem('replyflow_token');
        }

        // Update UI based on authentication state
        async function updateAuthUI() {
            const token = getToken();
            // Always restore saved limits for all platforms regardless of auth state. This
            // ensures the inputs show the user's last selected values even when
            // they are not logged in.
            loadXLimits();
            loadRedditLimits();
            loadBlueskyLimits();
            loadLinkedinLimits();
            loadGoogleLimits();
            loadTelegramLimits();
            loadThreadsLimits();
            loadYoutubeLimits();
            if (!token) {
                // When not authenticated, disable actions that require authentication (reply features and logs).
                // Account details are no longer displayed on the dashboard.
                // Disable prepare/post or analyze buttons for all platforms
                if (prepareXBtn) prepareXBtn.disabled = true;
                if (postXBtn) postXBtn.disabled = true;
                if (prepareRedditBtn) prepareRedditBtn.disabled = true;
                if (postRedditBtn) postRedditBtn.disabled = true;
                if (prepareBlueskyBtn) prepareBlueskyBtn.disabled = true;
                if (postBlueskyBtn) postBlueskyBtn.disabled = true;
                if (prepareLinkedinBtn) prepareLinkedinBtn.disabled = true;
                if (postLinkedinBtn) postLinkedinBtn.disabled = true;
                if (prepareGoogleBtn) prepareGoogleBtn.disabled = true;
                if (postGoogleBtn) postGoogleBtn.disabled = true;
                if (prepareTelegramBtn) prepareTelegramBtn.disabled = true;
                if (postTelegramBtn) postTelegramBtn.disabled = true;
                if (prepareThreadsBtn) prepareThreadsBtn.disabled = true;
                if (postThreadsBtn) postThreadsBtn.disabled = true;
                if (prepareYoutubeBtn) prepareYoutubeBtn.disabled = true;
                if (postYoutubeBtn) postYoutubeBtn.disabled = true;
                // Disable analyze buttons for Pinterest, Snapchat and TikTok
                if (analyzePinterestBtn) analyzePinterestBtn.disabled = true;
                if (analyzeSnapchatBtn) analyzeSnapchatBtn.disabled = true;
                if (analyzeTiktokBtn) analyzeTiktokBtn.disabled = true;
                // Disable connect buttons for Pinterest, Snapchat and TikTok
                if (connectPinterestBtn) {
                    connectPinterestBtn.textContent = 'Connect Pinterest';
                    connectPinterestBtn.disabled = true;
                }
                if (connectSnapchatBtn) {
                    connectSnapchatBtn.textContent = 'Connect Snapchat';
                    connectSnapchatBtn.disabled = true;
                }
                if (connectTiktokBtn) {
                    connectTiktokBtn.textContent = 'Connect TikTok';
                    connectTiktokBtn.disabled = true;
                }
                // Disable log buttons when not logged in
                if (viewLogsBtn) viewLogsBtn.disabled = true;
                if (clearLogsBtn) clearLogsBtn.disabled = true;
                // Disable connect buttons for X and Reddit when not logged in
                // Disable connect buttons for remaining platforms when not logged in
                if (connectXBtn) {
                    connectXBtn.textContent = 'Connect X';
                    connectXBtn.disabled = true;
                }
                if (connectRedditBtn) {
                    connectRedditBtn.textContent = 'Connect Reddit';
                    connectRedditBtn.disabled = true;
                }
                if (connectBlueskyBtn) {
                    connectBlueskyBtn.textContent = 'Connect Bluesky';
                    connectBlueskyBtn.disabled = true;
                }
                if (connectLinkedinBtn) {
                    connectLinkedinBtn.textContent = 'Connect LinkedIn';
                    connectLinkedinBtn.disabled = true;
                }
                if (connectGoogleBtn) {
                    connectGoogleBtn.textContent = 'Connect Google';
                    connectGoogleBtn.disabled = true;
                }
                if (connectTelegramBtn) {
                    connectTelegramBtn.textContent = 'Connect Telegram';
                    connectTelegramBtn.disabled = true;
                }
                if (connectThreadsBtn) {
                    connectThreadsBtn.textContent = 'Connect Threads';
                    connectThreadsBtn.disabled = true;
                }
                if (connectYoutubeBtn) {
                    connectYoutubeBtn.textContent = 'Connect YouTube';
                    connectYoutubeBtn.disabled = true;
                }
                // Already handled Pinterest, Snapchat, TikTok above
            } else {
                // When authenticated, show the user info section and enable reply actions.
                // There are no auth forms to hide in this version of the dashboard.
                if (prepareXBtn) prepareXBtn.disabled = false;
                if (postXBtn) postXBtn.disabled = false;
                if (prepareRedditBtn) prepareRedditBtn.disabled = false;
                if (postRedditBtn) postRedditBtn.disabled = false;
                if (prepareBlueskyBtn) prepareBlueskyBtn.disabled = false;
                if (postBlueskyBtn) postBlueskyBtn.disabled = false;
                if (prepareLinkedinBtn) prepareLinkedinBtn.disabled = false;
                if (postLinkedinBtn) postLinkedinBtn.disabled = false;
                if (prepareGoogleBtn) prepareGoogleBtn.disabled = false;
                if (postGoogleBtn) postGoogleBtn.disabled = false;
                if (prepareTelegramBtn) prepareTelegramBtn.disabled = false;
                if (postTelegramBtn) postTelegramBtn.disabled = false;
                if (prepareThreadsBtn) prepareThreadsBtn.disabled = false;
                if (postThreadsBtn) postThreadsBtn.disabled = false;
                if (prepareYoutubeBtn) prepareYoutubeBtn.disabled = false;
                if (postYoutubeBtn) postYoutubeBtn.disabled = false;
                // Enable analyze buttons for Pinterest, Snapchat and TikTok
                if (analyzePinterestBtn) analyzePinterestBtn.disabled = false;
                if (analyzeSnapchatBtn) analyzeSnapchatBtn.disabled = false;
                if (analyzeTiktokBtn) analyzeTiktokBtn.disabled = false;
                // Enable log buttons when logged in
                if (viewLogsBtn) viewLogsBtn.disabled = false;
                if (clearLogsBtn) clearLogsBtn.disabled = false;
                // User account information is not displayed on the dashboard.  We no longer
                // fetch or update user details here. The dedicated account_settings page
                // handles fetching user info and subscription management.
                // Check which platforms are connected
                await checkXConnection();
                await checkRedditConnection();
                if (typeof checkBlueskyConnection === 'function') await checkBlueskyConnection();
                if (typeof checkLinkedinConnection === 'function') await checkLinkedinConnection();
                if (typeof checkGoogleConnection === 'function') await checkGoogleConnection();
                if (typeof checkTelegramConnection === 'function') await checkTelegramConnection();
                if (typeof checkThreadsConnection === 'function') await checkThreadsConnection();
                if (typeof checkYoutubeConnection === 'function') await checkYoutubeConnection();
                if (typeof checkPinterestConnection === 'function') await checkPinterestConnection();
                if (typeof checkSnapchatConnection === 'function') await checkSnapchatConnection();
                if (typeof checkTiktokConnection === 'function') await checkTiktokConnection();
            }
        }

        // Sign up handler (only attached if the sign up form exists). On the dashboard
        // we no longer include sign up fields, so this handler will not be set.
        if (signupBtn) {
            signupBtn.addEventListener('click', async () => {
                const email = signupEmail.value?.trim();
                const password = signupPassword.value;
                if (!email || !password) {
                    if (typeof authMessage !== 'undefined' && authMessage) {
                        authMessage.textContent = 'Please enter a valid email and password.';
                    }
                    return;
                }
                // Clear any existing message and show the spinner for feedback
                if (authMessage) authMessage.textContent = '';
                showSpinner();
                try {
                    // First attempt to sign up via GET. This avoids CORS preflight
                    // requests and works on platforms where only simple requests
                    // are allowed. We include credentials as query parameters.
                    const signupUrl = `${API_BASE_URL}/signup?email=${encodeURIComponent(email)}&password=${encodeURIComponent(password)}`;
                    let response = await fetch(signupUrl, { method: 'GET' });
                    // If the GET request is rejected (e.g. 405/403), fall back to POST.
                    if (!response.ok) {
                        // Attempt to parse the error message but ignore failures
                        let errorDetail = '';
                        try {
                            const errData = await response.json();
                            errorDetail = errData?.detail || '';
                        } catch (_) {
                            // ignore
                        }
                        // Only attempt POST if GET failed due to method issues
                        const postResponse = await fetch(`${API_BASE_URL}/signup`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ email, password }),
                        });
                        response = postResponse;
                        if (!response.ok) {
                            // Use the error detail from the second response if available
                            let errMsg = '';
                            try {
                                const postErr = await response.json();
                                errMsg = postErr?.detail || '';
                            } catch (_) {
                                // ignore
                            }
                            throw new Error(errMsg || errorDetail || 'Sign up failed');
                        }
                    }
                    // If we reach here the signup succeeded. Clear spinner and show toast.
                    hideSpinner();
                    showToast('Sign up successful. Please log in.', 'success');
                    if (signupEmail) signupEmail.value = '';
                    if (signupPassword) signupPassword.value = '';
                } catch (error) {
                    hideSpinner();
                    // Display a toast and update the inline auth message with the error.
                    const msg = error?.message || 'Sign up failed';
                    showToast(`Error: ${msg}`, 'error');
                    if (authMessage) authMessage.textContent = `Error: ${msg}`;
                }
            });
        }

        // Login handler (only attached if the login form exists). On the dashboard
        // we no longer include login fields, so this handler will not be set.
        if (loginBtn) {
            loginBtn.addEventListener('click', async () => {
                const email = loginEmail.value?.trim();
                const password = loginPassword.value;
                if (!email || !password) {
                    if (authMessage) authMessage.textContent = 'Please enter your email and password.';
                    return;
                }
                if (authMessage) authMessage.textContent = '';
                showSpinner();
                try {
                    // Attempt GET login first to avoid preflight and satisfy hosts that only allow GET.
                    const loginUrl = `${API_BASE_URL}/login?email=${encodeURIComponent(email)}&password=${encodeURIComponent(password)}`;
                    let response = await fetch(loginUrl, { method: 'GET' });
                    let data = null;
                    if (!response.ok) {
                        // Parse any details and then fall back to POST
                        let errorDetail = '';
                        try {
                            const errData = await response.json();
                            errorDetail = errData?.detail || '';
                        } catch (_) {
                            // ignore parse errors
                        }
                        // Fallback to POST request if GET fails
                        const postResponse = await fetch(`${API_BASE_URL}/login`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ email, password }),
                        });
                        response = postResponse;
                        data = await response.json().catch(() => null);
                        if (!response.ok || !data) {
                            const detail = (data && data.detail) || errorDetail || 'Login failed';
                            throw new Error(detail);
                        }
                    } else {
                        data = await response.json();
                    }
                    // If response is OK and data contains an access token, log the user in
                    const token = data?.access_token;
                    if (!token) {
                        throw new Error(data?.detail || 'Login failed');
                    }
                    setToken(token);
                    hideSpinner();
                    showToast('Logged in successfully.', 'success');
                    if (loginEmail) loginEmail.value = '';
                    if (loginPassword) loginPassword.value = '';
                    await updateAuthUI();
                } catch (error) {
                    hideSpinner();
                    const msg = error?.message || 'Login failed';
                    showToast(`Error: ${msg}`, 'error');
                    if (authMessage) authMessage.textContent = `Error: ${msg}`;
                }
            });
        }

        // Logout handler (only if the button exists on this page)
        if (logoutBtn) {
            logoutBtn.addEventListener('click', () => {
                // Clear the session token and refresh the UI. Account details are not managed on the dashboard.
                clearToken();
                updateAuthUI();
            });
        }

        // Subscription management handlers
        if (manageSubBtn) {
            manageSubBtn.addEventListener('click', async () => {
                // Trigger creation of a billing portal session via the API and redirect
                const token = getToken();
                if (!token) {
                    showToast('You must be logged in to manage your subscription.', 'error');
                    return;
                }
                showSpinner();
                try {
                    const response = await fetch(`${API_BASE_URL}/subscription/portal`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` },
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data.url) {
                            // Redirect to the Stripe portal URL to manage subscription
                            window.location.href = data.url;
                            return;
                        }
                        showToast('Unable to retrieve portal session.', 'error');
                    } else {
                        let errDetail = '';
                        try {
                            const errData = await response.json();
                            errDetail = errData?.detail || '';
                        } catch (_) {}
                        showToast(`Error: ${errDetail || 'Failed to create portal session.'}`, 'error');
                    }
                } catch (_) {
                    showToast('An error occurred while contacting the server.', 'error');
                } finally {
                    hideSpinner();
                }
            });
        }
        if (cancelSubBtn) {
            cancelSubBtn.addEventListener('click', async () => {
                const token = getToken();
                if (!token) {
                    showToast('You must be logged in to cancel your subscription.', 'error');
                    return;
                }
                // Ask for confirmation before canceling
                const confirmed = confirm('Are you sure you want to cancel your subscription? You will immediately be downgraded to the free plan.');
                if (!confirmed) return;
                showSpinner();
                try {
                    const response = await fetch(`${API_BASE_URL}/subscription/cancel`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` },
                    });
                    if (response.ok) {
                        // Refresh user info to reflect the free plan
                        await updateAuthUI();
                        showToast('Subscription canceled successfully.', 'success');
                    } else {
                        let errDetail = '';
                        try {
                            const errData = await response.json();
                            errDetail = errData?.detail || '';
                        } catch (_) {}
                        showToast(`Error: ${errDetail || 'Failed to cancel subscription.'}`, 'error');
                    }
                } catch (_) {
                    showToast('An error occurred while contacting the server.', 'error');
                } finally {
                    hideSpinner();
                }
            });
        }

        // Initialize UI on load
        // Load previously saved max_tokens value and update tone displays
        loadMaxTokens();
        updateToneDisplays();
        updateAuthUI();

        generateBtn.addEventListener('click', async () => {
            const comment = commentInput.value.trim();
            const tone = toneSelect.value;
            if (!comment) {
                replyResult.textContent = 'Please enter a comment to generate a reply.';
                return;
            }
            replyResult.textContent = '';
            // Show spinner while generating
            showSpinner();
            try {
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                // Persist the current max_tokens to localStorage
                saveMaxTokens();
                // Build request payload including optional max_tokens
                const payload = { comment, tone };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) {
                    payload.max_tokens = mtVal;
                }
                const response = await fetch(`${API_BASE_URL}/generate_reply`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload),
                });
                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(err || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                replyResult.textContent = data.reply || JSON.stringify(data, null, 2);
                showToast('Reply generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                replyResult.textContent = `Error: ${error.message}`;
                showToast(`Error: ${error.message}`, 'error');
            }
        });

        if (prepareBtn) prepareBtn.addEventListener('click', async () => {
            // Clear previous result and show spinner
            facebookResult.textContent = '';
            showSpinner();
            try {
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                // Build request body including tone and per‑page limits if provided
                // Persist the current max_tokens to localStorage
                saveMaxTokens();
                const bodyData = { tone: toneSelect.value };
                // Include max_tokens if specified
                const mt = parseInt(maxTokensInput.value);
                if (!isNaN(mt) && mt > 0) {
                    bodyData.max_tokens = mt;
                }
                const maxPostsVal = parseInt(maxPostsInput.value);
                const maxCommentsVal = parseInt(maxCommentsInput.value);
                if (!isNaN(maxPostsVal) && maxPostsVal > 0) {
                    bodyData.max_posts = maxPostsVal;
                }
                if (!isNaN(maxCommentsVal) && maxCommentsVal > 0) {
                    bodyData.max_comments = maxCommentsVal;
                }
                // Include selected page IDs from the multi-select if any
                const selectedIds = getSelectedPageIds();
                if (Array.isArray(selectedIds) && selectedIds.length > 0) {
                    bodyData.page_ids = selectedIds;
                }
                const response = await fetch(`${API_BASE_URL}/facebook/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(err || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                facebookResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies prepared successfully.', 'success');
            } catch (error) {
                hideSpinner();
                facebookResult.textContent = `Error: ${error.message}`;
                showToast(`Error: ${error.message}`, 'error');
            }
        });

        if (postBtn) postBtn.addEventListener('click', async () => {
            // Confirm with the user before posting actual replies.
            const proceed = confirm(
                'This will post replies to Facebook. Are you sure you want to proceed?'
            );
            if (!proceed) {
                return;
            }
            facebookResult.textContent = '';
            showSpinner();
            try {
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                // Build request body including tone and per‑page limits if provided
                // Persist the current max_tokens to localStorage
                saveMaxTokens();
                const bodyDataPost = { tone: toneSelect.value };
                // Include max_tokens if specified
                const mt2 = parseInt(maxTokensInput.value);
                if (!isNaN(mt2) && mt2 > 0) {
                    bodyDataPost.max_tokens = mt2;
                }
                const maxPostsVal2 = parseInt(maxPostsInput.value);
                const maxCommentsVal2 = parseInt(maxCommentsInput.value);
                if (!isNaN(maxPostsVal2) && maxPostsVal2 > 0) {
                    bodyDataPost.max_posts = maxPostsVal2;
                }
                if (!isNaN(maxCommentsVal2) && maxCommentsVal2 > 0) {
                    bodyDataPost.max_comments = maxCommentsVal2;
                }
                // Include selected page IDs from the multi-select if any
                const selectedIdsPost = getSelectedPageIds();
                if (Array.isArray(selectedIdsPost) && selectedIdsPost.length > 0) {
                    bodyDataPost.page_ids = selectedIdsPost;
                }
                const response = await fetch(`${API_BASE_URL}/facebook/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyDataPost),
                });
                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(err || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                facebookResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                facebookResult.textContent = `Error: ${error.message}`;
                showToast(`Error: ${error.message}`, 'error');
            }
        });

        // Connect Facebook handler. Redirects the user to the backend Facebook login route to start the OAuth flow.
        if (connectFacebookBtn) connectFacebookBtn.addEventListener('click', () => {
            // Retrieve the current auth token from localStorage. The backend requires a session token
            // to associate the OAuth flow with the logged‑in user. If no token is found, the
            // backend will redirect to the login page.
            const token = getToken();
            // Build the Facebook OAuth initiation URL, including the token if present.
            let url = `${API_BASE_URL}/facebook/login`;
            if (token) {
                url += `?token=${encodeURIComponent(token)}`;
            }
            // Open the OAuth flow in a new popup window so the dashboard remains visible.
            // This prevents the current page from navigating away to another domain and losing UI state.
            window.open(url, 'facebook_oauth', 'width=600,height=700');
            // Inform the user that a popup has opened
            showToast('A popup window has opened. Please complete the Facebook login.', 'info');
        });

        // Instagram integration handlers have been removed due to switching to a share-only model. Guard event listener definitions.
        if (connectInstagramBtn) connectInstagramBtn.addEventListener('click', () => {
            showToast('Instagram integration has been removed. Please use the Facebook share dialog instead.', 'info');
        });
        if (prepareInstagramBtn) prepareInstagramBtn.addEventListener('click', () => {
            showToast('Instagram integration has been removed. Please use the Facebook share dialog instead.', 'info');
        });
        if (postInstagramBtn) postInstagramBtn.addEventListener('click', () => {
            showToast('Instagram integration has been removed. Please use the Facebook share dialog instead.', 'info');
        });

        // X (Twitter) integration handlers
        // Connect X: opens a popup to trigger the backend connect endpoint.  On
        // completion the popup will post a message back to this window,
        // allowing updateAuthUI() to refresh connection status.  If no token is
        // available the backend will display a simple message.
        connectXBtn.addEventListener('click', () => {
            // Persist current max_tokens for consistency across sessions
            saveMaxTokens();
            // Build the connect URL with the user's session token
            const token = getToken();
            let url = `${API_BASE_URL}/x/connect`;
            if (token) {
                url += `?token=${encodeURIComponent(token)}`;
            }
            // Open the OAuth/connect flow in a popup window
            window.open(url, 'x_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the X connection.', 'info');
        });
        // Prepare X replies: fetch mentions and generate AI replies
        prepareXBtn.addEventListener('click', async () => {
            // Show spinner while we perform the call
            showSpinner();
            try {
                // Persist limits and token settings
                saveMaxTokens();
                saveXLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                // Build request body with tone, max_posts, max_comments and max_tokens
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) {
                    bodyData.max_tokens = mtVal;
                }
                const mpVal = parseInt(maxPostsXInput.value);
                if (!isNaN(mpVal) && mpVal > 0) {
                    bodyData.max_posts = mpVal;
                }
                const mcVal = parseInt(maxCommentsXInput.value);
                if (!isNaN(mcVal) && mcVal > 0) {
                    bodyData.max_comments = mcVal;
                }
                const response = await fetch(`${API_BASE_URL}/x/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                xResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to prepare X replies';
                xResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        // Post X replies: send generated replies back to X
        postXBtn.addEventListener('click', async () => {
            // Confirm before posting
            const proceed = confirm('This will post replies to X. Are you sure you want to proceed?');
            if (!proceed) return;
            showSpinner();
            try {
                // Persist limits and token settings
                saveMaxTokens();
                saveXLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                // Build request body with tone, max_posts, max_comments and max_tokens
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) {
                    bodyData.max_tokens = mtVal;
                }
                const mpVal = parseInt(maxPostsXInput.value);
                if (!isNaN(mpVal) && mpVal > 0) {
                    bodyData.max_posts = mpVal;
                }
                const mcVal = parseInt(maxCommentsXInput.value);
                if (!isNaN(mcVal) && mcVal > 0) {
                    bodyData.max_comments = mcVal;
                }
                const response = await fetch(`${API_BASE_URL}/x/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                xResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to post X replies';
                xResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // Reddit integration handlers
        connectRedditBtn.addEventListener('click', () => {
            // Persist current max_tokens for consistency across sessions
            saveMaxTokens();
            // Build the connect URL with session token
            const token = getToken();
            let url = `${API_BASE_URL}/reddit/connect`;
            if (token) {
                url += `?token=${encodeURIComponent(token)}`;
            }
            window.open(url, 'reddit_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the Reddit connection.', 'info');
        });
        // Prepare Reddit replies: fetch mentions/comments and generate replies
        prepareRedditBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                saveRedditLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) {
                    bodyData.max_tokens = mtVal;
                }
                const mpVal = parseInt(maxPostsRedditInput.value);
                if (!isNaN(mpVal) && mpVal > 0) {
                    bodyData.max_posts = mpVal;
                }
                const mcVal = parseInt(maxCommentsRedditInput.value);
                if (!isNaN(mcVal) && mcVal > 0) {
                    bodyData.max_comments = mcVal;
                }
                const response = await fetch(`${API_BASE_URL}/reddit/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                redditResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to prepare Reddit replies';
                redditResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        // Post Reddit replies: send them back to Reddit
        postRedditBtn.addEventListener('click', async () => {
            const proceed = confirm('This will post replies to Reddit. Are you sure you want to proceed?');
            if (!proceed) return;
            showSpinner();
            try {
                saveMaxTokens();
                saveRedditLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) {
                    bodyData.max_tokens = mtVal;
                }
                const mpVal = parseInt(maxPostsRedditInput.value);
                if (!isNaN(mpVal) && mpVal > 0) {
                    bodyData.max_posts = mpVal;
                }
                const mcVal = parseInt(maxCommentsRedditInput.value);
                if (!isNaN(mcVal) && mcVal > 0) {
                    bodyData.max_comments = mcVal;
                }
                const response = await fetch(`${API_BASE_URL}/reddit/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                redditResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to post Reddit replies';
                redditResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- Bluesky integration handlers ------------------------
        if (connectBlueskyBtn) connectBlueskyBtn.addEventListener('click', () => {
            // Persist current max_tokens and Bluesky limits for consistency
            saveMaxTokens();
            saveBlueskyLimits();
            const token = getToken();
            // Start the OAuth flow instead of using a preconfigured token.
            let url = `${API_BASE_URL}/bluesky/oauth/start`;
            if (token) {
                url += `?token=${encodeURIComponent(token)}`;
            }
            window.open(url, 'bluesky_oauth', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the Bluesky connection.', 'info');
        });
        if (prepareBlueskyBtn) prepareBlueskyBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                saveBlueskyLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsBlueskyInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsBlueskyInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/bluesky/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                blueskyResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to prepare Bluesky replies';
                blueskyResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        if (postBlueskyBtn) postBlueskyBtn.addEventListener('click', async () => {
            const proceed = confirm('This will post replies to Bluesky. Are you sure you want to proceed?');
            if (!proceed) return;
            showSpinner();
            try {
                saveMaxTokens();
                saveBlueskyLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsBlueskyInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsBlueskyInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/bluesky/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                blueskyResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to post Bluesky replies';
                blueskyResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- LinkedIn integration handlers ------------------------
        if (connectLinkedinBtn) connectLinkedinBtn.addEventListener('click', () => {
            saveMaxTokens();
            saveLinkedinLimits();
            const token = getToken();
            let url = `${API_BASE_URL}/linkedin/connect`;
            if (token) url += `?token=${encodeURIComponent(token)}`;
            window.open(url, 'linkedin_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the LinkedIn connection.', 'info');
        });
        if (prepareLinkedinBtn) prepareLinkedinBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                saveLinkedinLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsLinkedinInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsLinkedinInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/linkedin/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                linkedinResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to prepare LinkedIn replies';
                linkedinResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        if (postLinkedinBtn) postLinkedinBtn.addEventListener('click', async () => {
            const proceed = confirm('This will post replies to LinkedIn. Are you sure you want to proceed?');
            if (!proceed) return;
            showSpinner();
            try {
                saveMaxTokens();
                saveLinkedinLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsLinkedinInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsLinkedinInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/linkedin/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                linkedinResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to post LinkedIn replies';
                linkedinResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- Google Business Profile integration handlers ------------------------
        // Initiates the Google OAuth flow when the user clicks the connect button.  This
        // now points to our dedicated /google/oauth/start endpoint rather than the
        // legacy /google/connect endpoint.  A session token is appended as a query
        // parameter so that the backend can identify the current user during the
        // OAuth process.  A popup window will open to complete the Google
        // authorization.
        if (connectGoogleBtn) connectGoogleBtn.addEventListener('click', () => {
            saveMaxTokens();
            saveGoogleLimits();
            const token = getToken();
            // Use the new OAuth start endpoint instead of the older generic connect route.
            let url = `${API_BASE_URL}/google/oauth/start`;
            if (token) url += `?token=${encodeURIComponent(token)}`;
            window.open(url, 'google_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the Google connection.', 'info');
        });
        if (prepareGoogleBtn) prepareGoogleBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                saveGoogleLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsGoogleInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsGoogleInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/google/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                googleResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to prepare Google replies';
                googleResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        if (postGoogleBtn) postGoogleBtn.addEventListener('click', async () => {
            const proceed = confirm('This will post replies to Google reviews. Are you sure you want to proceed?');
            if (!proceed) return;
            showSpinner();
            try {
                saveMaxTokens();
                saveGoogleLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsGoogleInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsGoogleInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/google/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                googleResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to post Google replies';
                googleResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- Telegram integration handlers ------------------------
        if (connectTelegramBtn) connectTelegramBtn.addEventListener('click', () => {
            saveMaxTokens();
            saveTelegramLimits();
            const token = getToken();
            let url = `${API_BASE_URL}/telegram/connect`;
            if (token) url += `?token=${encodeURIComponent(token)}`;
            window.open(url, 'telegram_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the Telegram connection.', 'info');
        });
        if (prepareTelegramBtn) prepareTelegramBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                saveTelegramLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsTelegramInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsTelegramInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/telegram/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                telegramResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to prepare Telegram replies';
                telegramResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        if (postTelegramBtn) postTelegramBtn.addEventListener('click', async () => {
            const proceed = confirm('This will post replies to Telegram. Are you sure you want to proceed?');
            if (!proceed) return;
            showSpinner();
            try {
                saveMaxTokens();
                saveTelegramLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsTelegramInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsTelegramInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/telegram/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                telegramResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to post Telegram replies';
                telegramResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- Threads integration handlers ------------------------
        if (connectThreadsBtn) connectThreadsBtn.addEventListener('click', () => {
            saveMaxTokens();
            saveThreadsLimits();
            const token = getToken();
            let url = `${API_BASE_URL}/threads/connect`;
            if (token) url += `?token=${encodeURIComponent(token)}`;
            window.open(url, 'threads_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the Threads connection.', 'info');
        });
        if (prepareThreadsBtn) prepareThreadsBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                saveThreadsLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsThreadsInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsThreadsInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/threads/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                threadsResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to prepare Threads replies';
                threadsResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        if (postThreadsBtn) postThreadsBtn.addEventListener('click', async () => {
            const proceed = confirm('This will post replies to Threads. Are you sure you want to proceed?');
            if (!proceed) return;
            showSpinner();
            try {
                saveMaxTokens();
                saveThreadsLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsThreadsInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsThreadsInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/threads/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                threadsResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to post Threads replies';
                threadsResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- YouTube integration handlers ------------------------
        if (connectYoutubeBtn) connectYoutubeBtn.addEventListener('click', () => {
            // Persist current global and YouTube limits before connecting
            saveMaxTokens();
            saveYoutubeLimits();
            const token = getToken();
            // Initiate the OAuth flow by navigating to /youtube/oauth/start rather than
            // using static environment tokens.  Include the session token as a
            // query parameter so the backend can associate the state with this user.
            let url = `${API_BASE_URL}/youtube/oauth/start`;
            if (token) url += `?token=${encodeURIComponent(token)}`;
            window.open(url, 'youtube_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the YouTube connection.', 'info');
        });
        if (prepareYoutubeBtn) prepareYoutubeBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                saveYoutubeLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsYoutubeInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsYoutubeInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/youtube/prepare_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                youtubeResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies generated successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to prepare YouTube replies';
                youtubeResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        if (postYoutubeBtn) postYoutubeBtn.addEventListener('click', async () => {
            const proceed = confirm('This will post replies to YouTube. Are you sure you want to proceed?');
            if (!proceed) return;
            showSpinner();
            try {
                saveMaxTokens();
                saveYoutubeLimits();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const mpVal = parseInt(maxPostsYoutubeInput.value);
                if (!isNaN(mpVal) && mpVal > 0) bodyData.max_posts = mpVal;
                const mcVal = parseInt(maxCommentsYoutubeInput.value);
                if (!isNaN(mcVal) && mcVal > 0) bodyData.max_comments = mcVal;
                const response = await fetch(`${API_BASE_URL}/youtube/post_replies`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                youtubeResult.textContent = JSON.stringify(data, null, 2);
                showToast('Replies posted successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to post YouTube replies';
                youtubeResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- Pinterest integration handlers ------------------------
        if (connectPinterestBtn) connectPinterestBtn.addEventListener('click', () => {
            // Persist global token limits
            saveMaxTokens();
            const token = getToken();
            let url = `${API_BASE_URL}/pinterest/connect`;
            if (token) url += `?token=${encodeURIComponent(token)}`;
            window.open(url, 'pinterest_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the Pinterest connection.', 'info');
        });
        if (analyzePinterestBtn) analyzePinterestBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const response = await fetch(`${API_BASE_URL}/pinterest/analyze`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                pinterestResult.textContent = JSON.stringify(data, null, 2);
                showToast('Analytics fetched successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to fetch Pinterest analytics';
                pinterestResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- Snapchat integration handlers ------------------------
        if (connectSnapchatBtn) connectSnapchatBtn.addEventListener('click', () => {
            saveMaxTokens();
            const token = getToken();
            let url = `${API_BASE_URL}/snapchat/connect`;
            if (token) url += `?token=${encodeURIComponent(token)}`;
            window.open(url, 'snapchat_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the Snapchat connection.', 'info');
        });
        if (analyzeSnapchatBtn) analyzeSnapchatBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const response = await fetch(`${API_BASE_URL}/snapchat/analyze`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                snapchatResult.textContent = JSON.stringify(data, null, 2);
                showToast('Analytics fetched successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to fetch Snapchat analytics';
                snapchatResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });

        // ---------------------- TikTok integration handlers ------------------------
        if (connectTiktokBtn) connectTiktokBtn.addEventListener('click', () => {
            saveMaxTokens();
            const token = getToken();
            let url = `${API_BASE_URL}/tiktok/connect`;
            if (token) url += `?token=${encodeURIComponent(token)}`;
            window.open(url, 'tiktok_connect', 'width=600,height=700');
            showToast('A popup window has opened. Please complete the TikTok connection.', 'info');
        });
        if (analyzeTiktokBtn) analyzeTiktokBtn.addEventListener('click', async () => {
            showSpinner();
            try {
                saveMaxTokens();
                const headers = { 'Content-Type': 'application/json' };
                const token = getToken();
                if (token) headers['Authorization'] = `Bearer ${token}`;
                const bodyData = { tone: toneSelect.value };
                const mtVal = parseInt(maxTokensInput.value);
                if (!isNaN(mtVal) && mtVal > 0) bodyData.max_tokens = mtVal;
                const response = await fetch(`${API_BASE_URL}/tiktok/analyze_comments`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(bodyData),
                });
                if (!response.ok) {
                    const errText = await response.text().catch(() => 'Request failed');
                    throw new Error(errText || 'Request failed');
                }
                const data = await response.json();
                hideSpinner();
                tiktokResult.textContent = JSON.stringify(data, null, 2);
                showToast('Comment analysis fetched successfully.', 'success');
            } catch (error) {
                hideSpinner();
                const msg = error?.message || 'Failed to analyze TikTok comments';
                tiktokResult.textContent = `Error: ${msg}`;
                showToast(`Error: ${msg}`, 'error');
            }
        });
        // Failed replies log handlers. These buttons allow the user to view
        // any errors encountered while posting replies and to clear the log.
        if (viewLogsBtn) {
            viewLogsBtn.addEventListener('click', async () => {
                logResult.textContent = '';
                const token = getToken();
                if (!token) {
                    logResult.textContent = 'Please log in to view logs.';
                    showToast('Please log in to view logs.', 'error');
                    return;
                }
                showSpinner();
                try {
                    const response = await fetch(`${API_BASE_URL}/admin/failed_replies`, {
                        headers: { 'Authorization': `Bearer ${token}` },
                    });
                    if (!response.ok) {
                        const errText = await response.text().catch(() => 'Request failed');
                        throw new Error(errText || 'Request failed');
                    }
                    const logs = await response.json();
                    hideSpinner();
                    if (!Array.isArray(logs) || logs.length === 0) {
                        logResult.textContent = 'No failed reply logs found.';
                        showToast('No failed reply logs found.', 'info');
                    } else {
                        logResult.textContent = JSON.stringify(logs, null, 2);
                        showToast('Loaded failed reply logs.', 'success');
                    }
                } catch (error) {
                    hideSpinner();
                    logResult.textContent = `Error: ${error.message}`;
                    showToast(`Error: ${error.message}`, 'error');
                }
            });
        }
        if (clearLogsBtn) {
            clearLogsBtn.addEventListener('click', async () => {
                const token = getToken();
                if (!token) {
                    logResult.textContent = 'Please log in to clear logs.';
                    showToast('Please log in to clear logs.', 'error');
                    return;
                }
                const confirmClear = confirm('Are you sure you want to clear all logs?');
                if (!confirmClear) {
                    return;
                }
                showSpinner();
                try {
                    const response = await fetch(`${API_BASE_URL}/admin/failed_replies`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${token}` },
                    });
                    if (!response.ok) {
                        const errText = await response.text().catch(() => 'Request failed');
                        throw new Error(errText || 'Request failed');
                    }
                    hideSpinner();
                    logResult.textContent = 'Failed reply logs cleared.';
                    showToast('Failed reply logs cleared.', 'success');
                } catch (error) {
                    hideSpinner();
                    logResult.textContent = `Error: ${error.message}`;
                    showToast(`Error: ${error.message}`, 'error');
                }
            });
        }

        // Facebook & Instagram share functionality. These handlers allow users to share a URL
        // via the Facebook share dialog and embed a public Facebook page without requiring any
        // extended permissions or API integration. The handlers are guarded to ensure that
        // elements exist in the DOM before attaching listeners.
        if (shareFacebookBtn) shareFacebookBtn.addEventListener('click', () => {
            const url = shareUrlInput.value.trim();
            if (!url) {
                showToast('Please enter a URL to share.', 'error');
                return;
            }
            // Use the standard Facebook share dialog by opening a popup window. This does not
            // require authentication. See: https://www.facebook.com/sharer/sharer.php?u=...
            const shareLink = 'https://www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(url);
            window.open(shareLink, 'fb_share', 'width=700,height=600');
            showToast('Opened Facebook share dialog.', 'info');
        });
        if (embedPageBtn) embedPageBtn.addEventListener('click', () => {
            const pageUrl = pageUrlInput.value.trim();
            if (!pageUrl) {
                showToast('Please enter a page URL to embed.', 'error');
                return;
            }
            // Construct the src for the Facebook page plugin iframe. The width and height can
            // be adjusted as needed. Adapt container width ensures responsiveness.
            const src =
                'https://www.facebook.com/plugins/page.php?href=' +
                encodeURIComponent(pageUrl) +
                '&tabs=timeline&width=500&height=500&small_header=false&adapt_container_width=true&hide_cover=false&show_facepile=true';
            pageEmbedContainer.innerHTML =
                '<iframe src="' +
                src +
                '" width="500" height="500" style="border:none;overflow:hidden" scrolling="no" frameborder="0" allowfullscreen="true" allow="autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share"></iframe>';
            showToast('Embedded Facebook page.', 'success');
        });

        // Listen for messages from X or Reddit popups indicating that OAuth has completed.  When
        // a popup completes the OAuth flow it will post a message back to this window (for
        // example, 'x_connected' or 'reddit_connected').  We refresh the authenticated UI
        // state so that connect buttons update correctly and show a success toast.
        window.addEventListener('message', (event) => {
            const message = event.data;
            const validMessages = [
                'x_connected',
                'reddit_connected',
                'bluesky_connected',
                'linkedin_connected',
                'google_connected',
                'telegram_connected',
                'threads_connected',
                'youtube_connected',
                'pinterest_connected',
                'snapchat_connected',
                'tiktok_connected',
            ];
            if (validMessages.includes(message)) {
                updateAuthUI();
                showToast('Your account has been connected successfully.', 'success');
            }
        });

        // Removed legacy Facebook/Instagram message listener and connection check.

    // Check whether the current user has connected X (Twitter).  Calls the
    // /admin/x_tokens endpoint to see if any token records are present.  If
    // one or more tokens exist, the connect button is disabled and its
    // label reflects the connected state.  On error or no tokens, the
    // button is enabled to allow connection.
    async function checkXConnection() {
        const token = getToken();
        if (!token) {
            connectXBtn.textContent = 'Connect X';
            connectXBtn.disabled = true;
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/x_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    connectXBtn.textContent = 'X Connected';
                    connectXBtn.disabled = true;
                } else {
                    connectXBtn.textContent = 'Connect X';
                    connectXBtn.disabled = false;
                }
            } else {
                connectXBtn.textContent = 'Connect X';
                connectXBtn.disabled = false;
            }
        } catch (_) {
            connectXBtn.textContent = 'Connect X';
            connectXBtn.disabled = false;
        }
    }

    // Check whether the current user has connected Reddit.  Similar to
    // checkXConnection, this helper inspects the /admin/reddit_tokens endpoint.
    async function checkRedditConnection() {
        const token = getToken();
        if (!token) {
            connectRedditBtn.textContent = 'Connect Reddit';
            connectRedditBtn.disabled = true;
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/reddit_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    connectRedditBtn.textContent = 'Reddit Connected';
                    connectRedditBtn.disabled = true;
                } else {
                    connectRedditBtn.textContent = 'Connect Reddit';
                    connectRedditBtn.disabled = false;
                }
            } else {
                connectRedditBtn.textContent = 'Connect Reddit';
                connectRedditBtn.disabled = false;
            }
        } catch (_) {
            connectRedditBtn.textContent = 'Connect Reddit';
            connectRedditBtn.disabled = false;
        }
    }

    // Check whether the current user has connected Bluesky.  Queries /admin/bluesky_tokens
    // to determine whether a token exists.  Updates the connect button accordingly.
    async function checkBlueskyConnection() {
        const token = getToken();
        if (!token) {
            if (connectBlueskyBtn) {
                connectBlueskyBtn.textContent = 'Connect Bluesky';
                connectBlueskyBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/bluesky_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectBlueskyBtn) {
                        connectBlueskyBtn.textContent = 'Bluesky Connected';
                        connectBlueskyBtn.disabled = true;
                    }
                } else {
                    if (connectBlueskyBtn) {
                        connectBlueskyBtn.textContent = 'Connect Bluesky';
                        connectBlueskyBtn.disabled = false;
                    }
                }
            } else {
                if (connectBlueskyBtn) {
                    connectBlueskyBtn.textContent = 'Connect Bluesky';
                    connectBlueskyBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectBlueskyBtn) {
                connectBlueskyBtn.textContent = 'Connect Bluesky';
                connectBlueskyBtn.disabled = false;
            }
        }
    }

    // Check LinkedIn connection status by calling /admin/linkedin_tokens
    async function checkLinkedinConnection() {
        const token = getToken();
        if (!token) {
            if (connectLinkedinBtn) {
                connectLinkedinBtn.textContent = 'Connect LinkedIn';
                connectLinkedinBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/linkedin_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectLinkedinBtn) {
                        connectLinkedinBtn.textContent = 'LinkedIn Connected';
                        connectLinkedinBtn.disabled = true;
                    }
                } else {
                    if (connectLinkedinBtn) {
                        connectLinkedinBtn.textContent = 'Connect LinkedIn';
                        connectLinkedinBtn.disabled = false;
                    }
                }
            } else {
                if (connectLinkedinBtn) {
                    connectLinkedinBtn.textContent = 'Connect LinkedIn';
                    connectLinkedinBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectLinkedinBtn) {
                connectLinkedinBtn.textContent = 'Connect LinkedIn';
                connectLinkedinBtn.disabled = false;
            }
        }
    }

    // Check Google Business Profile connection status via /admin/google_tokens
    async function checkGoogleConnection() {
        const token = getToken();
        if (!token) {
            if (connectGoogleBtn) {
                connectGoogleBtn.textContent = 'Connect Google';
                connectGoogleBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/google_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectGoogleBtn) {
                        connectGoogleBtn.textContent = 'Google Connected';
                        connectGoogleBtn.disabled = true;
                    }
                } else {
                    if (connectGoogleBtn) {
                        connectGoogleBtn.textContent = 'Connect Google';
                        connectGoogleBtn.disabled = false;
                    }
                }
            } else {
                if (connectGoogleBtn) {
                    connectGoogleBtn.textContent = 'Connect Google';
                    connectGoogleBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectGoogleBtn) {
                connectGoogleBtn.textContent = 'Connect Google';
                connectGoogleBtn.disabled = false;
            }
        }
    }

    // Check Telegram connection status via /admin/telegram_tokens
    async function checkTelegramConnection() {
        const token = getToken();
        if (!token) {
            if (connectTelegramBtn) {
                connectTelegramBtn.textContent = 'Connect Telegram';
                connectTelegramBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/telegram_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectTelegramBtn) {
                        connectTelegramBtn.textContent = 'Telegram Connected';
                        connectTelegramBtn.disabled = true;
                    }
                } else {
                    if (connectTelegramBtn) {
                        connectTelegramBtn.textContent = 'Connect Telegram';
                        connectTelegramBtn.disabled = false;
                    }
                }
            } else {
                if (connectTelegramBtn) {
                    connectTelegramBtn.textContent = 'Connect Telegram';
                    connectTelegramBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectTelegramBtn) {
                connectTelegramBtn.textContent = 'Connect Telegram';
                connectTelegramBtn.disabled = false;
            }
        }
    }

    // Check Threads connection status via /admin/threads_tokens
    async function checkThreadsConnection() {
        const token = getToken();
        if (!token) {
            if (connectThreadsBtn) {
                connectThreadsBtn.textContent = 'Connect Threads';
                connectThreadsBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/threads_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectThreadsBtn) {
                        connectThreadsBtn.textContent = 'Threads Connected';
                        connectThreadsBtn.disabled = true;
                    }
                } else {
                    if (connectThreadsBtn) {
                        connectThreadsBtn.textContent = 'Connect Threads';
                        connectThreadsBtn.disabled = false;
                    }
                }
            } else {
                if (connectThreadsBtn) {
                    connectThreadsBtn.textContent = 'Connect Threads';
                    connectThreadsBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectThreadsBtn) {
                connectThreadsBtn.textContent = 'Connect Threads';
                connectThreadsBtn.disabled = false;
            }
        }
    }

    // Check YouTube connection status via /admin/youtube_tokens
    async function checkYoutubeConnection() {
        const token = getToken();
        if (!token) {
            if (connectYoutubeBtn) {
                connectYoutubeBtn.textContent = 'Connect YouTube';
                connectYoutubeBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/youtube_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectYoutubeBtn) {
                        connectYoutubeBtn.textContent = 'YouTube Connected';
                        connectYoutubeBtn.disabled = true;
                    }
                } else {
                    if (connectYoutubeBtn) {
                        connectYoutubeBtn.textContent = 'Connect YouTube';
                        connectYoutubeBtn.disabled = false;
                    }
                }
            } else {
                if (connectYoutubeBtn) {
                    connectYoutubeBtn.textContent = 'Connect YouTube';
                    connectYoutubeBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectYoutubeBtn) {
                connectYoutubeBtn.textContent = 'Connect YouTube';
                connectYoutubeBtn.disabled = false;
            }
        }
    }

    // Check Pinterest connection status via /admin/pinterest_tokens
    async function checkPinterestConnection() {
        const token = getToken();
        if (!token) {
            if (connectPinterestBtn) {
                connectPinterestBtn.textContent = 'Connect Pinterest';
                connectPinterestBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/pinterest_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectPinterestBtn) {
                        connectPinterestBtn.textContent = 'Pinterest Connected';
                        connectPinterestBtn.disabled = true;
                    }
                } else {
                    if (connectPinterestBtn) {
                        connectPinterestBtn.textContent = 'Connect Pinterest';
                        connectPinterestBtn.disabled = false;
                    }
                }
            } else {
                if (connectPinterestBtn) {
                    connectPinterestBtn.textContent = 'Connect Pinterest';
                    connectPinterestBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectPinterestBtn) {
                connectPinterestBtn.textContent = 'Connect Pinterest';
                connectPinterestBtn.disabled = false;
            }
        }
    }

    // Check Snapchat connection status via /admin/snapchat_tokens
    async function checkSnapchatConnection() {
        const token = getToken();
        if (!token) {
            if (connectSnapchatBtn) {
                connectSnapchatBtn.textContent = 'Connect Snapchat';
                connectSnapchatBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/snapchat_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectSnapchatBtn) {
                        connectSnapchatBtn.textContent = 'Snapchat Connected';
                        connectSnapchatBtn.disabled = true;
                    }
                } else {
                    if (connectSnapchatBtn) {
                        connectSnapchatBtn.textContent = 'Connect Snapchat';
                        connectSnapchatBtn.disabled = false;
                    }
                }
            } else {
                if (connectSnapchatBtn) {
                    connectSnapchatBtn.textContent = 'Connect Snapchat';
                    connectSnapchatBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectSnapchatBtn) {
                connectSnapchatBtn.textContent = 'Connect Snapchat';
                connectSnapchatBtn.disabled = false;
            }
        }
    }

    // Check TikTok connection status via /admin/tiktok_tokens
    async function checkTiktokConnection() {
        const token = getToken();
        if (!token) {
            if (connectTiktokBtn) {
                connectTiktokBtn.textContent = 'Connect TikTok';
                connectTiktokBtn.disabled = true;
            }
            return;
        }
        try {
            const res = await fetch(`${API_BASE_URL}/admin/tiktok_tokens`, {
                headers: { 'Authorization': `Bearer ${token}` },
            });
            if (res.ok) {
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    if (connectTiktokBtn) {
                        connectTiktokBtn.textContent = 'TikTok Connected';
                        connectTiktokBtn.disabled = true;
                    }
                } else {
                    if (connectTiktokBtn) {
                        connectTiktokBtn.textContent = 'Connect TikTok';
                        connectTiktokBtn.disabled = false;
                    }
                }
            } else {
                if (connectTiktokBtn) {
                    connectTiktokBtn.textContent = 'Connect TikTok';
                    connectTiktokBtn.disabled = false;
                }
            }
        } catch (_) {
            if (connectTiktokBtn) {
                connectTiktokBtn.textContent = 'Connect TikTok';
                connectTiktokBtn.disabled = false;
            }
        }
    }
    </script>
</body>
</html>